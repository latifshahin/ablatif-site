<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Professional Banking & Financial Services | Abdul Latif</title>
<meta name="description" content="Professional banking services by Abdul Latif — banking software, workflow automation, audit tools, financial research and advisory services in Bangladesh." />
<link rel="canonical" href="https://ablatif.com/services/" />
<link href="/font-awesome/css/font-awesome.min.css" rel="stylesheet" />

<!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-X4YNW0E3XG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-X4YNW0E3XG');
  </script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Person",
      "@id": "https://ablatif.com/#person",
      "name": "Abdul Latif",
      "url": "https://ablatif.com/",
      "jobTitle": "Banking & Financial Systems Specialist",
      "sameAs": [
        "https://www.facebook.com/latifmirabdul/",
        "https://x.com/latifju",
        "https://www.youtube.com/@DiptiYTV"
      ]
    },
    {
      "@type": "Organization",
      "@id": "https://ablatif.com/#organization",
      "name": "Abdul Latif – Professional Banking Services",
      "url": "https://ablatif.com/services/",
      "founder": { "@id": "https://ablatif.com/#person" },
      "areaServed": {
        "@type": "Country",
        "name": "Bangladesh"
      }
    },
    {
      "@type": "Service",
      "name": "Professional Banking & Financial Services",
      "provider": { "@id": "https://ablatif.com/#organization" },
      "serviceType": [
        "Banking Software Development",
        "Audit & Compliance Tools",
        "Workflow Automation",
        "Financial & Economic Research",
        "Professional Advisory",
        "Requested Review & Analysis"
      ],
      "areaServed": "Bangladesh"
    }
  ]
}
</script>


<style>
:root{
  --bg:#f4f6fb;
  --card:#ffffff;
  --text:#0b1220;
  --muted:#5b6475;
  --border:#d7dbe3;
  --ok:#1b7f3b;
  --bad:#b00020;
  --warn:#b26a00;
  --blue:#1f4fd8;
}
 /* Section */
    .section{ margin-top: 18px; }
    .section-head{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap: 12px;
      margin: 22px 2px 12px;
    }
    .section-head h2{
      margin:0;
      font-size: 20px;
      font-weight: 900;
      letter-spacing: -.2px;
    }
    .section-head .hint{
      color: var(--muted);
      font-size: 13px;
      font-family: Inter, sans-serif;
      font-weight: 800;
    }


.top-right-button {
    position: fixed; /* Positions relative to the browser window */
    top: 10px;      /* Distance from the top edge */
    right: 15px;    /* Distance from the right edge */
    /* Add other styling as needed */
    padding: 10px 20px;
    background-color: #ffffff;
    color: rgb(10, 94, 63);
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition-duration: 0.4s;
}
.top-right-button:hover {
  background-color: #4CAF50; /* Green */
  color: white;
}

*{box-sizing:border-box}
body{
  margin:0;
  padding:18px;
  font-family:Segoe UI, system-ui, -apple-system, Arial, Helvetica, sans-serif;
  background:var(--bg);
  color:var(--text);
}

h1{margin:0 0 12px 0; font-size:22px}
h2{margin:0 0 8px 0; font-size:16px}
h3{margin:0 0 8px 0; font-size:14px}
.small{font-size:13px}
.muted{color:var(--muted)}
.kpi{font-size:22px; font-weight:800}

.card{
  background:var(--card);
  border:1px solid rgba(0,0,0,.04);
  border-radius:14px;
  padding:14px 14px;
  margin-bottom:14px;
  box-shadow:0 4px 14px rgba(0,0,0,.08);
}

.row{display:flex; gap:12px; flex-wrap:wrap}
.col{flex:1 1 280px}
.col2{flex:1 1 520px}

.grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
.grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px}
.grid4{display:grid; grid-template-columns:repeat(4,1fr); gap:12px}
@media (max-width: 980px){
  .grid2,.grid3,.grid4{grid-template-columns:1fr}
}

.hr{height:1px; background:var(--border); margin:12px 0}
.pill{
  display:inline-flex; align-items:center; gap:8px;
  border:1px solid var(--border);
  background:#fff;
  border-radius:999px;
  padding:8px 12px;
}

input[type="file"]{width:100%}
input[type="text"], textarea, select{
  width:100%;
  border:1px solid var(--border);
  border-radius:12px;
  padding:8px 10px;
  font-size:13px;
  background:#fff;
  color:var(--text);
}

textarea{resize:vertical}
button{
  border:1px solid var(--border);
  background:#fff;
  border-radius:12px;
  padding:9px 12px;
  cursor:pointer;
  font-weight:700;
}
button.primary{background:var(--blue); border-color:var(--blue); color:#fff}
button.ghost{background:#fff}
button:disabled{opacity:.55; cursor:not-allowed}

.badge{display:inline-block; padding:3px 9px; border-radius:999px; font-weight:800; font-size:12px; border:1px solid var(--border)}
.badge.ok{color:var(--ok); border-color:rgba(27,127,59,.35); background:rgba(27,127,59,.07)}
.badge.bad{color:var(--bad); border-color:rgba(176,0,32,.35); background:rgba(176,0,32,.07)}
.badge.warn{color:var(--warn); border-color:rgba(178,106,0,.35); background:rgba(178,106,0,.07)}

.status-matched{color:var(--ok); font-weight:900}
.status-not-matched{color:var(--bad); font-weight:900}
.delta-good{color:var(--ok); font-weight:900}
.delta-bad{color:var(--bad); font-weight:900}

table{width:100%; border-collapse:collapse; font-size:13px}
th,td{border:1px solid var(--border); padding:6px 8px; text-align:center; vertical-align:middle; color:#000}
th{background:#f1f3f6; font-weight:800}
td.rowhdr{text-align:left; font-weight:800; background:#fbfbfc}

.scroll{max-height:260px; overflow:auto; border-radius:12px; border:1px solid var(--border)}
pre{
  margin:0; padding:10px 12px;
  border-radius:12px;
  background:#0b1220;
  color:#e6edf3;
  font-size:12px;
  overflow:auto;
}

.obsWrap{border:none; border-collapse:separate; border-spacing:12px 0; margin-top:10px}
.obsWrap td{border:none; vertical-align:top; padding:0}

@page{size:A4 portrait; margin:12mm}
@media print{
  body{background:#fff}
  .no-print{display:none !important}
  .card{box-shadow:none}
  .scroll{max-height:none; overflow:visible}
  table{page-break-inside:avoid; break-inside:avoid}
  #onePage{page-break-after:always}
}

.helpIcon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:18px;
  height:18px;
  margin-left:8px;
  border:1px solid var(--border);
  border-radius:50%;
  font-size:12px;
  line-height:1;
  color:var(--muted);
  cursor:help;
  user-select:none;
}
  .toolsFooterRow{
    display:flex;
    flex-wrap:wrap;
    gap:12px;
    margin-top:12px;
    align-items:stretch; /* makes cards same height */
  }
  .toolsFooterColWide{ flex:1 1 520px; min-width:320px; }
  .toolsFooterColNarrow{ flex:1 1 260px; min-width:240px; }

  .socialBtns{
    margin-top:10px;
    display:flex;
    gap:10px;
    flex-wrap:wrap;
    align-items:center;
  }
  .socialBtn{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:38px;
    height:38px;
    border:1px solid rgba(0,0,0,.12);
    border-radius:12px;
    text-decoration:none;
    font-size:18px;
    line-height:1;
  }
  .socialBtn:hover{ text-decoration:none; opacity:.9; }

  .footerSmallLinks a{
    font-size:14px;
    font-weight:600;
    text-decoration:none;
  }
  .footerSmallLinks a:hover{ text-decoration:underline; }
.toolsFooterRow > .card{
  flex: 1 1 320px;   /* or 520px if you want wider */
  min-width: 240px;
}

.helpIcon:hover{ border-color:var(--blue); color:var(--blue); }
</style>
</head>

<body>
<h1>Transfer Audit Tool v2.0</h1><button class="top-right-button"><a href="../index.html">&larr; Main Site</a></button>
<!-- ===================== Audit Tool: About (Paste on Top) ===================== -->
<section class="card" style="margin:12px 0; padding:12px;"
  data-help="About this tool: purpose, focus, functionality, users, and why it matters.">
  <details open>
    <summary style="cursor:pointer; display:flex; align-items:center; justify-content:space-between; gap:12px;">
      <span><b>About this Audit Tool</b> <span class="small muted">Purpose • Focus • Functionality</span></span>
      <span class="small muted">Click to expand/collapse</span>
    </summary>

    <div style="margin-top:10px" class="small">
      <p style="margin:8px 0;">
        This audit tool is designed to <b>compare and analyze bank transfer transactions recorded before and after Close of Business (COB)</b>.
        It supports audit and control review by comparing two independent sources:
        <b>HTML register (Before COB)</b> and <b>TXT register (After COB)</b>.
      </p>

      <div style="display:grid; grid-template-columns:repeat(auto-fit, minmax(220px, 1fr)); gap:10px;">
        <div style="border:1px solid #e5e5e5; border-radius:12px; padding:10px;">
          <div class="small muted"><b>Purpose</b></div>
          <div style="margin-top:6px;">
            Identify inconsistencies, missing legs, control weaknesses, and unusual patterns in transfer processing.
          </div>
        </div>

        <div style="border:1px solid #e5e5e5; border-radius:12px; padding:10px;">
          <div class="small muted"><b>Focus</b></div>
          <div style="margin-top:6px;">
            Integrity and completeness of postings, reference-level balance, segregation-of-duty, and system-user leakage.
          </div>
        </div>

        <div style="border:1px solid #e5e5e5; border-radius:12px; padding:10px;">
          <div class="small muted"><b>For Whom</b></div>
          <div style="margin-top:6px;">
            Internal Audit, Compliance/Risk, Operations Control, and supervisors reviewing daily transfer activity.
          </div>
        </div>

        <div style="border:1px solid #e5e5e5; border-radius:12px; padding:10px;">
          <div class="small muted"><b>Why It Matters</b></div>
          <div style="margin-top:6px;">
            Speeds up review, improves consistency, reduces manual error, and strengthens audit evidence.
          </div>
        </div>
      </div>

      <details style="margin-top:10px;">
        <summary style="cursor:pointer;"><b>Key Functionality (What it checks)</b></summary>
        <ul style="margin:8px 0 0 18px;">
          <li><b>HTML vs TXT comparison</b> (totals, counts, references)</li>
          <li><b>Unbalanced reference</b> (debit sum ≠ credit sum per FT ref)</li>
          <li><b>Orphan debit/credit</b> (missing opposite-side legs)</li>
          <li><b>Inputter & Authoriser analysis</b> (segregation-of-duty risks)</li>
          <li><b>System leakage</b> (system IDs appearing when excluded)</li>
          <li><b>Top transactions per inputter</b> (focus review on high-value items)</li>
          <li><b>Advanced indicators</b> (duplicate patterns, threshold splitting/structuring)</li>
        </ul>
      </details>

      <details style="margin-top:10px;">
        <summary style="cursor:pointer;"><b>Important Note</b></summary>
        <p style="margin:8px 0;">
          This tool does not “prove fraud” by itself. It highlights <b>exceptions and red flags</b> for professional judgment,
          supporting follow-up testing and evidence collection.
        </p>
      </details>
    </div>
  </details>
</section>
<!-- ===================== /Audit Tool: About ===================== -->

<div class="card no-print">
  <h2>1) Load registers</h2>
  <div class="grid3" style="margin-top:12px">
    <div class="card" style="margin:0" data-help=" Here you upload the HTML transfer register (Before COB). This is used as the baseline for totals, inputter summary and FT reference list. The tool dynamically detects the header row, so it should work even if column positions vary.">
      <div class="small muted">Before COB (HTML format transfer register)</div>
      <input type="file" id="fileHtml" accept=".html,.htm"/>
      <button class="btn" id="dlHtmlCsv" type="button" disabled style="margin-top:8px; padding:8px 10px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer;">Download HTML as CSV</button>
    </div>
    <div class="card" style="margin:0" data-help="Here you upload the TXT transfer register (After COB). This is used to compare with HTML (system users can be excluded, and 7-character normalization is applied).">
      <div class="small muted">After COB (TXT format transfer register)</div>
      <input type="file" id="fileTxt" accept=".txt"/>
      <button class="btn" id="dlTxtCsv" type="button" disabled style="margin-top:8px; padding:8px 10px; border-radius:10px; border:1px solid #ccc; background:#fff; cursor:pointer;">Download TXT as CSV</button>
    </div>
    <div class="card" style="margin:0" data-help="Opens the short/quick audit page (simplified workflow focusing on key risk indicators). Use it when you want a fast check, then return here for full matching and deep review.">
  <div class="row" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <div>
      <div class="small muted">Quick audit shortcut</div>
      <div class="small" style="margin-top:4px;">
        Open the simplified tool for a fast review of key red flags.
      </div>
    </div>

    <a href="/tools/transfer_short.html" target="_blank" rel="noopener"
       class="btn"
       style="text-decoration:none; white-space:nowrap; padding:8px 12px; border-radius:10px; border:1px solid #ccc;">
      Open quick audit →
    </a>
  </div>
</div>

  </div>

  <div class="grid3" style="margin-top:12px">
    <div class="card" style="margin:0" data-help="Counts rows where Inputter and Authoriser are different (after applying filters and 7-character normalization). Useful to spot segregation-of-duty issues.">
      <div class="small muted">Inputter ≠ Authoriser (Filtered)</div>
      <div class="small">HTML: <b id="exHtml">—</b> &nbsp; | &nbsp; TXT: <b id="exTxt">—</b></div>
    </div>
    <div class="card" style="margin:0" data-help="Counts debit or credit entries that have no matching opposite-side entry for the same reference (after filters). Helps find missing legs / incomplete postings.">
      <div class="small muted">Orphan Debit/Credit (Filtered)</div>
      <div class="small">HTML: <b id="orHtml">—</b> &nbsp; | &nbsp; TXT: <b id="orTxt">—</b></div>
    </div>
    <div class="card" style="margin:0" data-help="Lists TXT rows that still look like system-user activity even when 'Exclude system' is enabled (after normalization).">
      <div class="small muted">System leakage (TXT)</div>
      <div class="small">Detected: <b id="sysLeakN">—</b></div>
      <div class="small muted" id="sysLeakList">—</div>
    </div>
  </div>

  <div class="hr"></div>

  <div class="grid2">
    <div class="pill">
      <input type="checkbox" id="chkExcludeSystem" checked/>
      <div class="small">
        <b>Exclude system-generated inputters (TXT)</b><br/>
        <span class="muted">Applies to totals & inputter comparison</span>
      </div>
    </div>

    <div>
      <div class="small muted">System inputter list (comma-separated). Use <b>*</b> for prefix (example <code>EFTHO*</code>)</div>
      <textarea id="sysList" rows="2" placeholder="SMARTBANK, DATAUPDUS, EFTHO*, SYSTEM*, BATCH*"></textarea>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="saveSysList()">Save list</button>
        <button class="ghost" onclick="resetSysList()">Reset default</button>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid3">
    <div>
      <div class="small muted">HTML inputter filter</div>
      <select id="selHtmlInputter" onchange="renderAll()"><option value="">All</option></select>
    </div>
    <div>
      <div class="small muted">TXT inputter filter</div>
      <select id="selTxtInputter" onchange="renderAll()"><option value="">All</option></select>
    </div>
    <div style="display:flex; gap:10px; align-items:flex-end; justify-content:flex-end">
      <button class="primary" id="btnRun" onclick="runAudit()">Load & Compare</button>
      <button class="ghost" onclick="window.print()">Print / Save PDF</button>
    </div>
  </div>

  <div class="small muted" style="margin-top:10px">
    Tips: TXT inputter names can be truncated. This tool uses <b>prefix match</b> (TXT name must be a prefix of HTML name).
  </div>
</div>

<div id="onePage" class="card">
  <h2>One-page Audit Summary (Print / Save as PDF)</h2>
  <div class="grid3">
    <div class="card" style="margin:0">
      <div class="small muted">Result</div>
      <div id="kpiResult" class="kpi">—</div>
      <div id="kpiStatus" class="small muted">—</div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Missing FT (TXT → HTML)</div>
      <div id="kpiMissingTxt" class="kpi">—</div>
      <div class="small muted">and HTML → TXT: <span id="kpiMissingHtml">—</span></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">FT quality</div>
      <div class="small">
        HTML blank: <b id="qHtmlBlank">—</b>, invalid: <b id="qHtmlInvalid">—</b><br/>
        TXT blank: <b id="qTxtBlank">—</b>, invalid: <b id="qTxtInvalid">—</b>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Inputter Summary (HTML) — Count + Total Amount</div>
      <div class="scroll"><div id="tblHtmlInputter"></div></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Inputter Summary (TXT) — Count + Total Amount</div>
      <div class="scroll"><div id="tblTxtInputter"></div></div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="small muted">Observation</div>
  <div id="sumObservation" class="small">—</div>
</div>

<div class="card">
  <h2>2) Transaction & Inputter Analytics</h2>
  <div class="grid3" style="grid-template-columns:2fr 1fr 1fr;">
    <div class="card" style="margin-top:12px" data-help="For each inputter (first 7 chars), shows the top N biggest transactions (by side amount) from HTML and TXT after filters.">
  <div class="row" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
    <div>
      <div class="small muted">Top transactions per inputter</div>
      <div class="small">Shows biggest transactions for each inputter (detail view)</div>
    </div>

    <div class="row" style="display:flex; align-items:center; gap:8px;">
      <div class="small muted">Top N</div>
      <select id="topNPerUser" style="padding:6px 8px; border-radius:10px; border:1px solid #ccc;">
        <option value="5">5</option>
        <option value="10" selected>10</option>
        <option value="20">20</option>
      </select>
    </div>
  </div>

  <div id="topPerUserWrap" style="margin-top:10px">—</div>
</div>

    <div class="card" style="margin:0">
      <div class="small muted">Missing in HTML (TXT refs)</div>
      <div class="scroll"><div id="listMissingTxt"></div></div>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="downloadText('missing_in_html.txt', state.missingTxt.join('\n'))">Download .txt</button>
        <button class="ghost" onclick="downloadHtml('missing_in_html.html', state.missingTxt)">Download .html</button>
      </div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Missing in TXT (HTML refs)</div>
      <div class="scroll"><div id="listMissingHtml"></div></div>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="downloadText('missing_in_txt.txt', state.missingHtml.join('\n'))">Download .txt</button>
        <button class="ghost" onclick="downloadHtml('missing_in_txt.html', state.missingHtml)">Download .html</button>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Per inputter (Filtered, HTML)</div>
      <div class="scroll"><div id="tblHtmlPerInputter"></div></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Per inputter (Filtered, TXT — system excluded option applies)</div>
      <div class="scroll"><div id="tblTxtPerInputter"></div></div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Find transactions by user / FT / amount</div>
      <div class="grid3">
        <div>
          <div class="small muted">Inputter contains</div>
          <input type="text" id="qInputter" placeholder="e.g., MOAZZEM, REBEKA"/>
        </div>
        <div>
          <div class="small muted">FT reference contains</div>
          <input type="text" id="qFt" placeholder="e.g., FT26033"/>
        </div>
        <div>
          <div class="small muted">Min amount</div>
          <input type="text" id="qMin" placeholder="e.g., 5000"/>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="primary" onclick="runSearch()">Search</button>
        <button class="ghost" onclick="clearSearch()">Clear</button>
      </div>
      <div class="small muted" style="margin-top:10px">Search runs on both HTML + TXT (filtered). Shows top 200 rows.</div>
      <div class="scroll" style="margin-top:10px"><div id="tblSearch"></div></div>
    </div>

    <div class="card" style="margin:0">
      <div class="small muted">Debug / Notes</div>
      <pre id="debug">Ready.</pre>
    </div>
  </div>
</div>


  <!-- Advanced Checks (bottom) -->
  <div class="card" style="margin-top:12px" data-help="Additional red-flag checks (do not prove fraud alone). These highlight references that are unbalanced, repeated patterns, and possible threshold-splitting behaviour.">
    <div class="small muted">Advanced checks (bottom)</div>
    <div class="small">These checks help you prioritize review. They do not change the existing layout above.</div>

    <div class="row" style="display:flex; gap:12px; align-items:flex-end; flex-wrap:wrap; margin-top:10px">
      <div>
        <div class="small muted">Threshold limit</div>
        <input id="thrLimit" type="number" value="500000" style="padding:6px 8px; border-radius:10px; border:1px solid var(--border); width:160px" />
      </div>
      <div>
        <div class="small muted">Window below limit (%)</div>
        <input id="thrWindowPct" type="number" value="5" min="1" max="20" style="padding:6px 8px; border-radius:10px; border:1px solid var(--border); width:160px" />
      </div>
      <div>
        <button class="btn" id="btnAdvRefresh" type="button" style="padding:8px 12px; border-radius:10px; border:1px solid var(--border); background:#fff; cursor:pointer">
          Refresh advanced checks
        </button>
      </div>
      <div class="small muted" id="advHint" style="flex:1; min-width:220px"></div>
    </div>

    <div class="grid3" style="margin-top:12px; grid-template-columns:1fr;">
      <div class="card" style="margin:0">
        <div class="small muted">1) Unbalanced reference (Debit sum ≠ Credit sum)</div>
        <div class="small" id="advUnbalSummary">—</div>
        <div class="scroll" style="max-height:240px; margin-top:8px"><table id="advUnbalTbl"></table></div>
      </div>

      <div class="card" style="margin:0; margin-top:12px">
        <div class="small muted">2) Duplicate reference / amount patterns</div>
        <div class="small" id="advDupSummary">—</div>
        <div class="scroll" style="max-height:240px; margin-top:8px"><table id="advDupTbl"></table></div>
      </div>

      <div class="card" style="margin:0; margin-top:12px">
        <div class="small muted">3) Threshold splitting detection (possible structuring)</div>
        <div class="small" id="advSplitSummary">—</div>
        <div class="scroll" style="max-height:240px; margin-top:8px"><table id="advSplitTbl"></table></div>
      </div>
    </div>
  </div>


<script>
// --------------------------- State ---------------------------
const state = {
  htmlTxns: [],
  txtTxns: [],
  stats: null,
  missingTxt: [],
  missingHtml: [],
  sysDefault: "SMARTBANK, DATAUPDUS, EFTHO*, SYSTEM*, BATCH*, T24, T24USER",
  sysPatterns: [],
};

// --------------------------- Utilities ---------------------------

// --------------------------- Help tooltips ---------------------------

function addHelpIcons(){
  // EASIEST FUTURE EDIT:
  // Put help text directly on a card:
  //   <div class="card" data-help="My text...">
  // That always wins.
  //
  // Optional fallback map by card title (the visible .small.muted text).
  const HELP = {
    "Inputter ≠ Authoriser (Filtered)":
      "Counts rows where Inputter and Authoriser are different (after applying filters and 7-character normalization). Useful to spot segregation-of-duty issues.",
    "Orphan Debit/Credit (Filtered)":
      "Counts debit or credit entries that have no matching opposite-side entry for the same reference (after filters). Helps find missing legs / incomplete postings.",
    "System leakage (TXT)":
      "Lists TXT rows that still look like system-user activity even when 'Exclude system' is enabled (after normalization).",

    // Upload cards (optional – only used if data-help is missing)
    "Before COB (HTML format transfer register)":
      "Upload the HTML transfer register (Before COB). Used as the baseline for totals, inputter summary and FT reference list.",
    "After COB (TXT format transfer register)":
      "Upload the TXT transfer register (After COB). Used to compare with HTML (system users can be excluded).",
    "For easy audit you can bist this link":
      "Opens the short/quick audit page in a new tab."
  };

  const normalizeTitle = (s)=> (s||"").replace(/\s+/g," ").trim();

  document.querySelectorAll(".card").forEach(card=>{
    // IMPORTANT BUGFIX:
    // Cards are nested inside other cards. If we do card.querySelector(".small.muted"),
    // the *outer* card can "see" a nested title and attach the tooltip to the wrong place,
    // causing your inner card to end up with the DEFAULT text.
    //
    // So: only pick a title element that belongs to THIS card (not a nested card).
    const candidates = card.querySelectorAll(".small.muted, h2, h3, strong");
    let titleEl = null;
    for(const el of candidates){
      const ownerCard = el.closest(".card");
      if(ownerCard === card){
        titleEl = el;
        break;
      }
    }
    if(!titleEl) return;

    // Don't add twice
    if(titleEl.querySelector(":scope > .helpIcon")) return;

    // Manual per-card help (editable in HTML): <div class="card" data-help="...">
    const manual = (card.getAttribute("data-help") || "").trim();

    // Read only the *text nodes* of the title (so previously added "?" never pollutes the title)
    const rawTitle = Array.from(titleEl.childNodes)
      .filter(n => n.nodeType === Node.TEXT_NODE)
      .map(n => n.textContent)
      .join("");

    const title = normalizeTitle(rawTitle);
    const tip =
      manual ||
      HELP[title] ||
      "Shows a summary for this card based on the current filters (HTML vs TXT).";

    const icon = document.createElement("span");
    icon.className = "helpIcon";
    icon.textContent = "?";
    icon.title = tip;

    titleEl.appendChild(icon);
  });
}

function log(msg){
  const el = document.getElementById('debug');
  el.textContent = (el.textContent + "\n" + msg).trim();
  el.scrollTop = el.scrollHeight;
}
function fmt(n){
  const x = Number(n||0);
  return new Intl.NumberFormat('en-US', {minimumFractionDigits:2, maximumFractionDigits:2}).format(x);
}
function num(s){
  if(s==null) return 0;
  const t = String(s).replace(/,/g,'').trim();
  const v = parseFloat(t);
  return isNaN(v) ? 0 : v;
}
function uniq(arr){ return Array.from(new Set(arr)); }

function norm7(s){
  const t = String(s||"").trim().toUpperCase();
  return t ? t.slice(0,7) : "(BLANK)";
}

function saveSysList(){
  const v = (document.getElementById('sysList').value || "").trim();
  localStorage.setItem('tr_audit_syslist', v || state.sysDefault);
  loadSysList();
  renderAll();
  alert("Saved ✅");
}
function resetSysList(){
  localStorage.setItem('tr_audit_syslist', state.sysDefault);
  loadSysList();
  renderAll();
}
function loadSysList(){
  const v = localStorage.getItem('tr_audit_syslist');
  const raw = (v && v.trim()) ? v : state.sysDefault;
  document.getElementById('sysList').value = raw;
  state.sysPatterns = raw.split(',').map(x=>x.trim().toUpperCase()).filter(Boolean);
}
function isSystemInputter(name){
  const n = String(name||"").trim().toUpperCase();
  if(!n) return false;
  for(const p of state.sysPatterns){
    if(!p) continue;
    if(p.endsWith('*')){
      const pref = p.slice(0,-1);
      if(n.startsWith(pref)) return true;
    }else{
      if(n===p) return true;
    }
  }
  return false;
}
function prefixMatch(txtName, htmlName){
  // Compare inputters using first 7 characters only (bank ID variations: REBEKA022 vs REBEKA0222 etc.)
  return norm7(txtName) === norm7(htmlName);
}
function downloadText(filename, content){
  const blob = new Blob([content||""], {type:"text/plain;charset=utf-8"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function downloadHtml(filename, refs){
  const rows = (refs||[]).map(r=>`<tr><td>${escapeHtml(r)}</td></tr>`).join("");
  const content = `<!doctype html><meta charset="utf-8"><title>${escapeHtml(filename)}</title>
  <style>body{font-family:Arial;padding:16px}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px 8px}</style>
  <h3>${escapeHtml(filename)}</h3><table><thead><tr><th>FT Reference</th></tr></thead><tbody>${rows}</tbody></table>`;
  const blob = new Blob([content], {type:"text/html;charset=utf-8"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

// --------------------------- Top transactions per inputter (detail view) ---------------------------
function topTxnsPerInputterBoth(htmlFiltered, txtFiltered, perN = 10){
  const m = new Map(); // inputter7 -> array of txns

  function pushTxn(t, src){
    const inputter = ((t.inputter || "") + "").slice(0,7);
    const debit = num(t.debitAmt);
    const credit = num(t.creditAmt);

    // Decide "side" for display and pick the corresponding amount.
    // If both present (HTML often has both), we prefer DEBIT when equal.
    const side = (debit >= credit) ? "DEBIT" : "CREDIT";
    const amount = (side === "DEBIT") ? debit : credit;

    if(!inputter || !amount) return;

    const arr = m.get(inputter) || [];
    arr.push({
      inputter,
      ref: t.ref || "",
      side,
      amount,
      src,

      // Account info (best effort: present for HTML; for TXT only the side-specific one may exist)
      drAcc: t.drAcc || "",
      crAcc: t.crAcc || "",
      drTitle: t.drTitle || "",
      crTitle: t.crTitle || ""
    });
    m.set(inputter, arr);
  }

  htmlFiltered.forEach(t => pushTxn(t, "HTML"));
  txtFiltered.forEach(t => pushTxn(t, "TXT"));

  // sort each inputter group and keep top N
  for(const [k, arr] of m){
    arr.sort((a,b) => (b.amount||0) - (a.amount||0));
    m.set(k, arr.slice(0, perN));
  }
  return m;
}

function renderTopPerUser(map){
  const wrap = document.getElementById("topPerUserWrap");
  if(!wrap) return;

  const inputters = Array.from(map.keys()).sort((a,b)=> a.localeCompare(b));
  if(inputters.length === 0){
    wrap.textContent = "—";
    return;
  }

  function showOrNA(v, na){
    const x = (v||"").trim();
    return x ? escapeHtml(x) : `<span class="muted">${escapeHtml(na)}</span>`;
  }

  wrap.innerHTML = inputters.map(inp => {
    const rows = map.get(inp) || [];
    const totalShown = rows.reduce((s,r)=> s + (r.amount||0), 0);

    const table = `
      <table style="width:100%; border-collapse:collapse; margin-top:8px">
        <thead>
          <tr>
            <th style="text-align:left; padding:6px;">#</th>
            <th style="text-align:left; padding:6px;">Src</th>
            <th style="text-align:left; padding:6px;">Ref</th>
            <th style="text-align:left; padding:6px;">Side</th>
            <th style="text-align:right; padding:6px;">Amount</th>
            <th style="text-align:left; padding:6px;">Debit Ac No</th>
            <th style="text-align:left; padding:6px;">Debit Account</th>
            <th style="text-align:left; padding:6px;">Credit Ac No</th>
            <th style="text-align:left; padding:6px;">Credit Account</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map((r, i) => {
            const debitNA  = (r.side === "DEBIT")  ? "—" : "Debit account not found";
            const creditNA = (r.side === "CREDIT") ? "—" : "Credit account not found";
            return `
            <tr>
              <td style="padding:6px;">${i+1}</td>
              <td style="padding:6px;">${escapeHtml(r.src)}</td>
              <td style="padding:6px; font-family:monospace;">${escapeHtml(r.ref)}</td>
              <td style="padding:6px;">${escapeHtml(r.side)}</td>
              <td style="padding:6px; text-align:right;"><b>${fmt(r.amount)}</b></td>
              <td style="padding:6px; font-family:monospace;">${showOrNA(r.drAcc, debitNA)}</td>
              <td style="padding:6px;">${showOrNA(r.drTitle, debitNA)}</td>
              <td style="padding:6px; font-family:monospace;">${showOrNA(r.crAcc, creditNA)}</td>
              <td style="padding:6px;">${showOrNA(r.crTitle, creditNA)}</td>
            </tr>
          `}).join("")}
        </tbody>
      </table>
    `;

    return `
      <details class="card" style="margin-top:10px; padding:10px; border:1px solid var(--border); border-radius:14px; box-shadow:none;">
        <summary style="cursor:pointer; display:flex; align-items:center; justify-content:space-between; gap:12px;">
          <span><b>${escapeHtml(inp)}</b> <span class="small muted">(top ${rows.length})</span></span>
          <span class="small muted">sum shown: <b>${fmt(totalShown)}</b></span>
        </summary>
        ${table}
      </details>
    `;
  }).join("");
}

function updateTopPerUser(){
  const perN = Number(document.getElementById("topNPerUser")?.value || 10);
  if(!state.stats){
    const wrap = document.getElementById("topPerUserWrap");
    if(wrap) wrap.textContent = "—";
    return;
  }
  const m = topTxnsPerInputterBoth(state.stats.htmlFiltered, state.stats.txtFiltered, perN);
  renderTopPerUser(m);
}
// --------------------------- Advanced Checks ---------------------------
function aggByRef(list){
  const m = new Map(); // ref -> {debit, credit, dCount, cCount, rows:[]}
  for(const t of (list||[])){
    const ref = (t.ref||"").trim();
    if(!ref) continue;
    const debit = num(t.debitAmt);
    const credit = num(t.creditAmt);
    const side = debit>0 ? "DEBIT" : (credit>0 ? "CREDIT" : "");
    const amt = Math.max(debit, credit);

    if(!m.has(ref)){
      m.set(ref, {ref, debit:0, credit:0, dCount:0, cCount:0, rows:[]});
    }
    const r = m.get(ref);
    if(debit>0){ r.debit += debit; r.dCount += 1; }
    if(credit>0){ r.credit += credit; r.cCount += 1; }
    r.rows.push({
      src: t.src || "",
      inputter: t.inputter || "",
      authoriser: t.authoriser || "",
      side,
      amt,
      drAcc: t.drAcc || "",
      drTitle: t.drTitle || "",
      crAcc: t.crAcc || "",
      crTitle: t.crTitle || ""
    });
  }
  return m;
}

function renderSimpleTable(elId, header, rowsHtml){
  const el = document.getElementById(elId);
  if(!el) return;
  if(!rowsHtml){
    el.innerHTML = "";
    return;
  }
  el.innerHTML = `<thead><tr>${header.map(h=>`<th>${h}</th>`).join("")}</tr></thead><tbody>${rowsHtml}</tbody>`;
}

function updateAdvancedChecks(){
  if(!state.stats){
    setText("advUnbalSummary","—");
    setText("advDupSummary","—");
    setText("advSplitSummary","—");
    renderSimpleTable("advUnbalTbl",[], "");
    renderSimpleTable("advDupTbl",[], "");
    renderSimpleTable("advSplitTbl",[], "");
    return;
  }

  const html = state.stats.htmlFiltered || [];
  const txt  = state.stats.txtFiltered || [];

  // ---------- 1) Unbalanced refs ----------
  function buildUnbal(list, srcLabel){
    const m = aggByRef(list);

    function pickDebitInfo(r){
      // best-effort: find a debit-side row with debit account details
      const row = (r.rows||[]).find(x => x.side==="DEBIT" && (x.drAcc || x.drTitle));
      return {
        dAcc: row?.drAcc || "",
        dName: row?.drTitle || ""
      };
    }
    function pickCreditInfo(r){
      // best-effort: find a credit-side row with credit account details
      const row = (r.rows||[]).find(x => x.side==="CREDIT" && (x.crAcc || x.crTitle));
      return {
        cAcc: row?.crAcc || "",
        cName: row?.crTitle || ""
      };
    }

    const out = [];
    for(const [ref, r] of m){
      const diff = (r.debit - r.credit);
      if(Math.abs(diff) > 0.0001){
        const d = pickDebitInfo(r);
        const c = pickCreditInfo(r);
        const inps = Array.from(new Set((r.rows||[]).map(x=>(x.inputter||"").trim()).filter(Boolean))).join(", ");
        const auths = Array.from(new Set((r.rows||[]).map(x=>(x.authoriser||"").trim()).filter(Boolean))).join(", ");
        out.push({
          src: srcLabel,
          ref,
          inputters: inps,
          authorisers: auths,
          debit: r.debit,
          credit: r.credit,
          diff,
          dAcc: d.dAcc,
          dName: d.dName,
          cAcc: c.cAcc,
          cName: c.cName
        });
      }
    }
    out.sort((a,b)=> Math.abs(b.diff)-Math.abs(a.diff));
    return out;
  }
  const unHtml = buildUnbal(html, "HTML");
  const unTxt  = buildUnbal(txt, "TXT");
  const unAll = unHtml.concat(unTxt);

  setText("advUnbalSummary", `Found: ${unAll.length} (HTML ${unHtml.length}, TXT ${unTxt.length})`);
  renderSimpleTable(
    "advUnbalTbl",
    ["Src","Ref","Inputter(s)","Authoriser(s)","Debit sum","Credit sum","Δ Difference","Debit Ac No","Debit Account","Credit Ac No","Credit Account"],
    unAll.slice(0,150).map(r=>`
      <tr>
        <td>${escapeHtml(r.src)}</td>
        <td style="font-family:monospace">${escapeHtml(r.ref)}</td>
        <td>${escapeHtml(r.inputters||"") || '<span class="muted">—</span>'}</td>
        <td>${escapeHtml(r.authorisers||"") || '<span class="muted">—</span>'}</td>
        <td style="text-align:right">${fmt(r.debit)}</td>
        <td style="text-align:right">${fmt(r.credit)}</td>
        <td style="text-align:right" class="${r.diff===0?'':'delta-bad'}">${fmt(r.diff)}</td>
        <td style="font-family:monospace">${escapeHtml(r.dAcc || "") || '<span class="muted">—</span>'}</td>
        <td>${escapeHtml(r.dName || "") || '<span class="muted">—</span>'}</td>
        <td style="font-family:monospace">${escapeHtml(r.cAcc || "") || '<span class="muted">—</span>'}</td>
        <td>${escapeHtml(r.cName || "") || '<span class="muted">—</span>'}</td>
      </tr>`).join("")
  );

  // ---------- 2) Duplicate reference/amount patterns ----------
  // Flag refs where more than one DEBIT line or more than one CREDIT line exists (per source),
  // OR unusually many lines overall for the same ref.
  function buildDup(list, srcLabel){
    const m = aggByRef(list);
    const out = [];
    for(const [ref, r] of m){
      const totalLines = r.rows.length;
      const suspicious = (r.dCount > 1) || (r.cCount > 1) || (totalLines > 2);
      if(!suspicious) continue;

      // also show the most common amount(s)
      const amtMap = new Map();
      for(const row of r.rows){
        const key = String(row.amt || 0);
        amtMap.set(key, (amtMap.get(key)||0) + 1);
      }
      const topAmt = Array.from(amtMap.entries()).sort((a,b)=>b[1]-a[1])[0];
      const inps = Array.from(new Set((r.rows||[]).map(x=>(x.inputter||"").trim()).filter(Boolean))).join(", ");
      const auths = Array.from(new Set((r.rows||[]).map(x=>(x.authoriser||"").trim()).filter(Boolean))).join(", ");
      out.push({
        src: srcLabel, ref,
        inputters: inps,
        authorisers: auths,
        totalLines,
        dCount: r.dCount, cCount: r.cCount,
        topAmt: topAmt ? Number(topAmt[0]) : 0,
        topAmtN: topAmt ? topAmt[1] : 0
      });
    }
    out.sort((a,b)=> (b.totalLines-a.totalLines) || (b.topAmtN-a.topAmtN));
    return out;
  }
  const dupHtml = buildDup(html, "HTML");
  const dupTxt  = buildDup(txt, "TXT");
  const dupAll = dupHtml.concat(dupTxt);

  setText("advDupSummary", `Found: ${dupAll.length} (HTML ${dupHtml.length}, TXT ${dupTxt.length})`);
  renderSimpleTable(
    "advDupTbl",
    ["Src","Ref","Inputter(s)","Authoriser(s)","Lines","Debits","Credits","Most common amount (n)"],
    dupAll.slice(0,200).map(r=>`
      <tr>
        <td>${escapeHtml(r.src)}</td>
        <td style="font-family:monospace">${escapeHtml(r.ref)}</td>
        <td>${escapeHtml(r.inputters||"") || '<span class="muted">—</span>'}</td>
        <td>${escapeHtml(r.authorisers||"") || '<span class="muted">—</span>'}</td>
        <td style="text-align:right">${r.totalLines}</td>
        <td style="text-align:right">${r.dCount}</td>
        <td style="text-align:right">${r.cCount}</td>
        <td style="text-align:right">${fmt(r.topAmt)} <span class="small muted">(${r.topAmtN})</span></td>
      </tr>`).join("")
  );

  // ---------- 3) Threshold splitting detection ----------
  // Detect inputters with many transactions just below a chosen limit (structuring).
  const limit = Number(document.getElementById("thrLimit")?.value || 500000);
  const pct = Number(document.getElementById("thrWindowPct")?.value || 5);
  const low = limit * (1 - (pct/100));
  setText("advHint", `Window: ${fmt(low)} to ${fmt(limit)} (inclusive). Showing filtered data (respecting dropdown + exclude-system).`);

  function buildSplit(list, srcLabel){
    const m = new Map(); // inputter -> {count,total,refs:[]}
    for(const t of list){
      const inputter = (t.inputter||"").trim();
      const debit = num(t.debitAmt), credit = num(t.creditAmt);
      const amt = Math.max(debit, credit);
      if(!inputter || !amt) continue;
      if(amt < low || amt > limit) continue;

      if(!m.has(inputter)){
        m.set(inputter, {src:srcLabel, inputter, authorisers:new Set(), count:0, total:0, max:0, refs:[]});
      }
      const r = m.get(inputter);
      if(t.authoriser) r.authorisers.add((t.authoriser||"").trim());
      r.count += 1;
      r.total += amt;
      if(amt > r.max) r.max = amt;
      if(r.refs.length < 6) r.refs.push(t.ref || "");
    }
    const out = Array.from(m.values()).filter(r=> r.count >= 3).map(r=>({...r, authorisers: Array.from(r.authorisers||[]).join(", ")})); // require 3+ near-limit txns
    out.sort((a,b)=> (b.total-a.total) || (b.count-a.count));
    return out;
  }
  const spHtml = buildSplit(html, "HTML");
  const spTxt  = buildSplit(txt, "TXT");
  const spAll = spHtml.concat(spTxt);

  setText("advSplitSummary", `Found: ${spAll.length} (requires ≥ 3 txns in window). HTML ${spHtml.length}, TXT ${spTxt.length}.`);
  renderSimpleTable(
    "advSplitTbl",
    ["Src","Inputter","Authoriser(s)","Count","Total in window","Max","Sample refs"],
    spAll.slice(0,200).map(r=>`
      <tr>
        <td>${escapeHtml(r.src)}</td>
        <td class="rowhdr">${escapeHtml(r.inputter)}</td>
        <td>${escapeHtml(r.authorisers||"") || '<span class="muted">—</span>'}</td>
        <td style="text-align:right">${r.count}</td>
        <td style="text-align:right">${fmt(r.total)}</td>
        <td style="text-align:right">${fmt(r.max)}</td>
        <td style="font-family:monospace">${escapeHtml(r.refs.filter(Boolean).join(", "))}</td>
      </tr>`).join("")
  );
}


// --------------------------- Parsers ---------------------------
// HTML: detect header indices dynamically from the "Daily Transfer Register" table
function parseHtmlRegister(htmlText){
  const doc = new DOMParser().parseFromString(htmlText, "text/html");
  const trs = Array.from(doc.querySelectorAll("tr"));
  let header = null;
  let headerIdx = {};
  const norm = s => (s||"").replace(/\u00a0/g,' ').trim();

  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => norm(td.textContent));
    if(tds.length >= 15 && tds.some(x => x.toLowerCase() === "trans.rf.no")){
      header = tds;
      header.forEach((h,i)=>{ headerIdx[h.toLowerCase()] = i; });
      break;
    }
  }
  if(!header){
    log("⚠️ HTML header row not found. Using fallback scan (FT-based).");
    return parseHtmlFallback(doc);
  }

  function get(tds, key){
    const i = headerIdx[key.toLowerCase()];
    if(i==null) return "";
    return (tds[i]||"").trim();
  }

  const out = [];
  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => norm(td.textContent));
    if(tds.length !== header.length) continue;
    const trno = get(tds, "tr");
    if(!/^\d+$/.test(trno)) continue;

    const ref = get(tds, "trans.rf.no");
    if(!ref) continue;

    out.push({
      src:"HTML",
      tr: trno,
      ref: ref.trim(),
      debitAmt: num(get(tds, "debit.amt")),
      creditAmt: num(get(tds, "credit.amt")),
      inputterRaw: get(tds, "inputter"),
      authoriserRaw: get(tds, "authoriser"),
      inputter: norm7(get(tds, "inputter")),
      authoriser: norm7(get(tds, "authoriser")),
      time: get(tds, "time"),
      drAcc: get(tds, "debit.ac.no"),
      crAcc: get(tds, "credit.ac.no"),
      drTitle: get(tds, "debit.acct.title"),
      crTitle: get(tds, "credit.acct.title"),
      drCat: get(tds, "dr.category"),
      crCat: get(tds, "cr.category"),
      type: get(tds, "type"),
    });
  }
  return out;
}

function parseHtmlFallback(doc){
  // fallback: scan for FT in TDs; assume columns: ... FT ref ... inputter later
  const out = [];
  const trs = Array.from(doc.querySelectorAll("tr"));
  let idx=0;
  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => (td.textContent||"").replace(/\u00a0/g,' ').trim());
    const ft = tds.find(x => /^FT[0-9A-Z]{4,}$/i.test(x));
    if(!ft) continue;
    const inputterRaw = (tds[tds.indexOf(ft)+2]||"").trim(); // heuristic
    out.push({src:"HTML", tr:String(++idx), ref:ft, debitAmt:0, creditAmt:0, inputterRaw, authoriserRaw:"", inputter:norm7(inputterRaw), authoriser:"", time:""});
  }
  return out;
}

// TXT: parse lines that contain FT token and amount columns; pick inputter token after FT
function parseTxtRegister(txtText){
  const lines = txtText.split(/\r?\n/);
  const out = [];

  function looksUserId(x){
    return /^[A-Z0-9]+$/i.test(x||"") && /[A-Z]/i.test(x||"") && /\d/.test(x||"");
  }

  for(const line of lines){
    if(!/\bFT[0-9A-Z]{4,}\b/i.test(line)) continue;

    const parts = line.trim().split(/\s+/);
    const ftIdx = parts.findIndex(p => /^FT[0-9A-Z]{4,}$/i.test(p));
    if(ftIdx < 0) continue;

    const ref = parts[ftIdx];

    // Find a time token after FT if present (HH:MM)
    let time = "";
    let timeIdx = -1;
    for(let i=ftIdx+1; i<parts.length; i++){
      if(/^\d{2}:\d{2}$/.test(parts[i])) { timeIdx = i; time = parts[i]; break; }
    }
    const end = (timeIdx>-1) ? timeIdx : parts.length;

    // Amounts:
    // TXT register is *usually* 2-line per transaction (one debit-side line + one credit-side line),
    // each line often contains only ONE amount. If we treat that single amount as both debit+credit,
    // totals become doubled. So:
    // - if we see 2+ decimal amounts on the same line => treat as a combined line containing BOTH legs
    // - if we see exactly 1 amount => classify the line as debit-side or credit-side and set the other side to 0
    const decs = parts.filter(p => /^[0-9,]+\.[0-9]{2}$/.test(p));
    let debitAmt = 0, creditAmt = 0;
    let isDebitSide = true;
    let combinedLine = false;

    if(decs.length >= 2){
      combinedLine = true;
      debitAmt  = num(decs[0]);
      creditAmt = num(decs[decs.length-1]);
      // For combined lines we will later SPLIT into two records (one debit, one credit),
      // but we still keep these here for reference.
      isDebitSide = true;
    }else if(decs.length === 1){
      const amt = num(decs[0]);

      // Heuristic side detection using fixed columns (more reliable than token length):
      // - If the LEFT account field is present (after the line serial), it is a DEBIT-side line.
      // - If the LEFT field is blank and the details start later, it is a CREDIT-side line.
      const leftAcctField = line.slice(3, 28).trim(); // chars right after serial
      isDebitSide = leftAcctField.length > 0;

      if(isDebitSide){
        debitAmt = amt;
        creditAmt = 0;
      }else{
        debitAmt = 0;
        creditAmt = amt;
      }
    }
    // USER EXTRACTION RULE (bank culture):
    // - If inputter id is 9 chars -> a SPACE exists before authoriser id (separate tokens)
    // - If inputter id is 10 chars -> it may be ATTACHED with authoriser in the same token
    // Therefore we inspect the first token after FT.
    const after = parts.slice(ftIdx+1, end).filter(Boolean);
    let inputter = "", authoriser = "";

    if(after.length){
      const t0 = after[0];
      // If attached: long token that starts with 10-char inputter
      if(t0.length > 10 && looksUserId(t0.slice(0,10))){
        inputter = t0.slice(0,10);
        authoriser = t0.slice(10);
        // If authoriser didn't come out clean (e.g., trailing junk), fallback to next token
        if(!looksUserId(authoriser) && after.length>=2 && looksUserId(after[1])){
          authoriser = after[1];
        }
      }else{
        // Separate tokens (typically 9-char inputter followed by authoriser)
        inputter = t0;
        if(after.length>=2) authoriser = after[1];
      }

      // Extra safety: if inputter token looks like garbage but second token looks like user id
      if(!looksUserId(inputter) && after.length>=2 && looksUserId(after[1])){
        inputter = after[1];
        authoriser = after.length>=3 ? after[2] : authoriser;
      }
    }


    // Extract account no/title from fixed-width layout (best-effort).
    // IMPORTANT: Some TXT rows contain BOTH legs on the same line (debit+credit together).
    // In that case we extract BOTH debit and credit accounts/titles and SPLIT into two records
    // so auditors can see if any leg is missing.
    let drAcc = "", crAcc = "", drTitle = "", crTitle = "";

    // Grab first+last amount positions so we can parse left (debit) and right (credit) blocks reliably
    const amtRe = /[0-9,]+\.[0-9]{2}/g;
    const allAmt = Array.from(line.matchAll(amtRe));
    const firstAmtIdx = allAmt.length ? allAmt[0].index : -1;
    const lastAmtIdx  = allAmt.length ? allAmt[allAmt.length-1].index : -1;

    function extractAcctTitle(preText, which){
    // which: "first" or "last" TR occurrence inside preText tokens
    const pre = (preText || "").trimEnd();
    const toks = pre.trim().split(/\s+/).filter(Boolean);
    const trTok = (parts[0] || "").trim();
    if(!trTok || toks.length < 4) return {acc:"", title:""};

    let trPos = -1;
    if(which === "first"){
    trPos = toks.indexOf(trTok);
    }else{
    for(let i=toks.length-1; i>=0; i--){
    if(toks[i] === trTok){ trPos = i; break; }
    }
    }
    if(trPos < 0) return {acc:"", title:""};

    const accNo = toks[trPos+1] || "";
    const title = toks.slice(trPos+3).join(" ").trim(); // skip legacy/code token at +2
    return {acc:accNo, title};
    }

    if(firstAmtIdx > 0){
    // Debit-side fields come before the FIRST amount
    const debitPre = line.slice(0, firstAmtIdx);
    const d = extractAcctTitle(debitPre, "first");
    drAcc = d.acc; drTitle = d.title;
    }
    if(lastAmtIdx > 0 && lastAmtIdx !== firstAmtIdx){
    // Credit-side fields are best extracted using the text before the LAST amount
    const creditPre = line.slice(0, lastAmtIdx);
    const c = extractAcctTitle(creditPre, "last");
    crAcc = c.acc; crTitle = c.title;
    }else if(!isDebitSide && firstAmtIdx > 0){
    // Single-amount credit-side line
    const creditPre = line.slice(0, firstAmtIdx);
    const c = extractAcctTitle(creditPre, "last");
    crAcc = c.acc; crTitle = c.title;
    }

    // Push records:
    // - combined line => split into 2 records (DEBIT and CREDIT)
    // - single-side line => one record
    const base = {
    src:"TXT",
    tr: parts[0] || "",
    ref,
    inputterRaw: (inputter||"").trim(),
    authoriserRaw: (authoriser||"").trim(),
    inputter: norm7(inputter),
    authoriser: norm7(authoriser),
    time: (time||"").trim(),
    raw: line
    };

    if(combinedLine){
    out.push({
    ...base,
    debitAmt: debitAmt,
    creditAmt: 0,
    drAcc, drTitle,
    crAcc: "", crTitle: ""
    });
    out.push({
    ...base,
    debitAmt: 0,
    creditAmt: creditAmt,
    drAcc: "", drTitle: "",
    crAcc, crTitle
    });
    }else{
    out.push({
    ...base,
    debitAmt,
    creditAmt,
    drAcc: isDebitSide ? drAcc : "",
    drTitle: isDebitSide ? drTitle : "",
    crAcc: isDebitSide ? "" : crAcc,
    crTitle: isDebitSide ? "" : crTitle
    });
    }

  }
  return out;
}

// --------------------------- Audit Engine ---------------------------
function buildIndex(txns){
  const m = new Map();
  for(const t of txns){
    const k = (t.ref||"").trim();
    if(!k) continue;
    if(!m.has(k)) m.set(k, []);
    m.get(k).push(t);
  }
  return m;
}

function ftQuality(txns){
  const fmtOk = /^FT[0-9A-Z]{6,}$/i;
  let blank=0, invalid=0;
  const samples=[];
  for(const t of txns){
    const r = (t.ref||"").trim();
    if(!r){ blank++; continue; }
    if(!fmtOk.test(r)){
      invalid++;
      if(samples.length<5) samples.push(r);
    }
  }
  return {blank, invalid, samples};
}

function summarizeByInputter(txns, opts){
  const {excludeSystem=false} = opts||{};
  const m = new Map();
  for(const t of txns){
    const raw = (t.inputterRaw!=null ? t.inputterRaw : t.inputter) || "";
    const key = (t.inputter||"").trim() || norm7(raw);
    if(excludeSystem && isSystemInputter(raw)) continue;
    if(!m.has(key)) m.set(key, {inputter:key, tx:0, debit:0, credit:0, maxAmt:0, maxRef:""});
    const r = m.get(key);
    r.tx += 1;
    r.debit += num(t.debitAmt);
    r.credit += num(t.creditAmt);
    const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
    if(amt > r.maxAmt){
      r.maxAmt = amt;
      r.maxRef = t.ref;
    }
  }
  return Array.from(m.values()).sort((a,b)=>b.tx-a.tx);
}

function countExceptions(txns){
  // inputter != authoriser (both present, case-insensitive)
  let n=0;
  for(const t of txns){
    const i = (t.inputter||"").trim().toUpperCase();
    const a = (t.authoriser||"").trim().toUpperCase();
    if(i && a && i !== a) n++;
  }
  return n;
}
function countOrphans(txns){
  // orphan = only one side has amount (>0) and the other is 0
  let n=0;
  for(const t of txns){
    const d = num(t.debitAmt), c = num(t.creditAmt);
    if((d>0 && c===0) || (c>0 && d===0)) n++;
  }
  return n;
}
function systemLeakReport(txtAll){
  // list system inputters found in TXT with counts
  const m = new Map();
  for(const t of txtAll){
    const inp = (t.inputter||"").trim();
    if(inp && isSystemInputter(inp)){
      m.set(inp, (m.get(inp)||0)+1);
    }
  }
  const arr = Array.from(m.entries()).sort((a,b)=>b[1]-a[1]);
  return {count: arr.reduce((a,[,v])=>a+v,0), top: arr.slice(0,8)};
}

function totals(txns, opts){
  const {excludeSystem=false, filterInputter=""} = opts||{};
  let d=0,c=0, dr=0, cr=0;
  for(const t of txns){
    const inp=(t.inputter||"").trim();
    const raw=(t.inputterRaw!=null ? t.inputterRaw : inp);
    if(filterInputter && inp!==filterInputter) continue;
    if(excludeSystem && isSystemInputter(raw)) continue;
    const da=num(t.debitAmt), ca=num(t.creditAmt);
    d+=da; c+=ca;
    if(da>0) dr++;
    if(ca>0) cr++;
  }
  return {debit:d, credit:c, drCount:dr, crCount:cr};
}

function runCompare(opts){
  opts = opts || {};

  const excludeSystem = document.getElementById('chkExcludeSystem').checked;

  // filters
  const fHtml = opts.ignoreFilters ? "" : (document.getElementById('selHtmlInputter').value || "");
  const fTxt  = opts.ignoreFilters ? "" : (document.getElementById('selTxtInputter').value || "");

  const htmlFiltered = state.htmlTxns.filter(t => !fHtml || (t.inputter||"")===fHtml);
  const txtFilteredRaw = state.txtTxns.filter(t => !fTxt || (t.inputter||"")===fTxt);
  const txtFiltered = excludeSystem ? txtFilteredRaw.filter(t => !isSystemInputter(t.inputterRaw||t.inputter)) : txtFilteredRaw;

  const idxHtml = buildIndex(htmlFiltered);
  const idxTxt  = buildIndex(txtFiltered);

  const missingTxt = []; // in TXT but not in HTML
  for(const [ref] of idxTxt){
    if(!idxHtml.has(ref)) missingTxt.push(ref);
  }
  const missingHtml = []; // in HTML but not in TXT
  for(const [ref] of idxHtml){
    if(!idxTxt.has(ref)) missingHtml.push(ref);
  }

  state.missingTxt = missingTxt.sort();
  state.missingHtml = missingHtml.sort();

  // Inputter compare: after excluding system on TXT and applying filters,
  // compare sets using prefix logic
  const htmlInps = uniq(htmlFiltered.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();
  const txtInps  = uniq(txtFiltered.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();

  const onlyHtml = [];
  const onlyTxt = [];
  for(const h of htmlInps){
    const matched = txtInps.some(t => prefixMatch(t,h));
    if(!matched) onlyHtml.push(h);
  }
  for(const t of txtInps){
    const matched = htmlInps.some(h => prefixMatch(t,h));
    if(!matched) onlyTxt.push(t);
  }

  const htmlTot = totals(htmlFiltered, {excludeSystem:false});
  const txtTot  = totals(txtFiltered, {excludeSystem:false}); // already excluded
  const dDelta = htmlTot.debit - txtTot.debit;
  const cDelta = htmlTot.credit - txtTot.credit;
  const bothZero = (Math.abs(dDelta) < 0.005 && Math.abs(cDelta) < 0.005);

  const qHtml = ftQuality(htmlFiltered);
  const qTxt  = ftQuality(txtFiltered);

  const resultBadge = (missingTxt.length===0 && missingHtml.length===0 && bothZero && onlyHtml.length===0 && onlyTxt.length===0)
    ? {text:"MATCHED", cls:"ok"} : {text:"DISCREPANCY", cls:"bad"};

  // Highest transaction (filtered)
  let hi = null;
  function considerHi(list, src){
    for(const t of list){
      const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
      if(!hi || amt > hi.amt){
        hi = {amt, ref:t.ref, inputter:t.inputter, src};
      }
    }
  }
  considerHi(htmlFiltered, "HTML");
  considerHi(txtFiltered, "TXT");

  // build stats for render
  return {
    excludeSystem, fHtml, fTxt,
    htmlFiltered, txtFiltered,
    missingTxt, missingHtml,
    onlyHtml, onlyTxt,
    htmlTot, txtTot, dDelta, cDelta, bothZero,
    qHtml, qTxt,
    resultBadge,
    hi
  };
}

// --------------------------- Rendering ---------------------------
function setHtml(id, html){ const el=document.getElementById(id); if(el) el.innerHTML=html; }
function setText(id, t){ const el=document.getElementById(id); if(el) el.textContent=t; }

function renderTableInputterSummary(arr){
  const rowsArr = arr || [];
  const sumTx = rowsArr.reduce((a,r)=>a+(r.tx||0),0);
  const sumDebit = rowsArr.reduce((a,r)=>a+num(r.debit),0);
  const sumCredit = rowsArr.reduce((a,r)=>a+num(r.credit),0);

  const rows = rowsArr.map(r=>`
    <tr>
      <td class="rowhdr">${escapeHtml(r.inputter)}</td>
      <td>${r.tx}</td>
      <td>${fmt(r.debit)}</td>
      <td>${fmt(r.credit)}</td>
      <td>${fmt(r.maxAmt)}</td>
      <td class="rowhdr">${escapeHtml(r.maxRef||"")}</td>
    </tr>`).join("");

  const tfoot = `
    <tfoot>
      <tr>
        <td class="rowhdr">TOTAL</td>
        <td><b>${sumTx}</b></td>
        <td><b>${fmt(sumDebit)}</b></td>
        <td><b>${fmt(sumCredit)}</b></td>
        <td colspan="2"></td>
      </tr>
    </tfoot>`;

  return `
  <table>
    <thead><tr>
      <th>Inputter</th><th>Tx</th><th>Debit</th><th>Credit</th><th>Max Amt</th><th>Max Ref</th>
    </tr></thead>
    <tbody>${rows || `<tr><td colspan="6" class="rowhdr">—</td></tr>`}</tbody>
    ${rowsArr.length ? tfoot : ""}
  </table>`;
}


function renderMissingList(refs){
  if(!refs || !refs.length) return `<div class="small muted">—</div>`;
  const rows = refs.slice(0,500).map(r=>`<div class="small">${escapeHtml(r)}</div>`).join("");
  return rows + (refs.length>500 ? `<div class="small muted">… +${refs.length-500} more</div>` : "");
}

function buildObservation(stats){
  const inpOk = (stats.onlyHtml.length===0 && stats.onlyTxt.length===0);
  const inpStatus = inpOk ? "MATCHED" : "NOT MATCHED";
  const inpBadge = inpOk ? "status-matched" : "status-not-matched";
  const onlyHtml = stats.onlyHtml.slice(0,10).join(", ");
  const onlyTxt  = stats.onlyTxt.slice(0,10).join(", ");

  const deltaCls = stats.bothZero ? "delta-good" : "delta-bad";

  const totalsTbl = `
    <table aria-label="Totals compare">
      <thead><tr><th></th><th>Debit Total</th><th>Credit Total</th></tr></thead>
      <tbody>
        <tr><td class="rowhdr">HTML</td><td>${fmt(stats.htmlTot.debit)}</td><td>${fmt(stats.htmlTot.credit)}</td></tr>
        <tr><td class="rowhdr">TXT (system excluded)</td><td>${fmt(stats.txtTot.debit)}</td><td>${fmt(stats.txtTot.credit)}</td></tr>
        <tr>
          <td class="rowhdr">Δ Difference</td>
          <td><span class="${deltaCls}">Δ ${fmt(stats.dDelta)}</span></td>
          <td><span class="${deltaCls}">Δ ${fmt(stats.cDelta)}</span></td>
        </tr>
      </tbody>
    </table>`;

  const countTbl = `
    <table aria-label="Debit/Credit counts">
      <thead><tr><th></th><th>Debit Count</th><th>Credit Count</th></tr></thead>
      <tbody>
        <tr><td class="rowhdr">HTML</td><td>${stats.htmlTot.drCount}</td><td>${stats.htmlTot.crCount}</td></tr>
        <tr><td class="rowhdr">TXT (system excluded)</td><td>${stats.txtTot.drCount}</td><td>${stats.txtTot.crCount}</td></tr>
      </tbody>
    </table>`;

  const sysExcluded = stats.excludeSystem ? uniq(state.txtTxns.filter(t=>isSystemInputter(t.inputterRaw||t.inputter)).map(t=>t.inputter)).sort() : [];
  const sysList = sysExcluded.length ? sysExcluded.join(", ") : "—";

  return `
Result: ${stats.resultBadge.text} found between Before COB (HTML) and After COB (TXT) registers.<br>
Status: <b>${stats.resultBadge.cls==="ok" ? "CLEARED" : "ACTION REQUIRED"}</b> (Manual review & verification).<br>
TXT missing in HTML (Before COB): <b>${stats.missingTxt.length}</b>; HTML missing in TXT (After COB): <b>${stats.missingHtml.length}</b><br>
Inputter check (filtered): <span class="${inpBadge}">${inpStatus}</span>
${inpOk ? "— Inputter matched (prefix match applied for truncated TXT names)." :
  `— Only in HTML: <b>${escapeHtml(onlyHtml || "—")}</b>${stats.onlyTxt.length?`; Only in TXT: <b>${escapeHtml(onlyTxt||"—")}</b>`:""}`
}
<br>
Totals compare (TXT excludes system inputters):<br>
<table class="obsWrap" aria-label="Observation tables"><tr><td>${totalsTbl}</td><td>${countTbl}</td></tr></table>
<br>
Excluded system inputters (TXT): <b>${escapeHtml(sysList)}</b><br>
FT reference quality: HTML blank <b>${stats.qHtml.blank}</b>, invalid-format <b>${stats.qHtml.invalid}</b>; TXT blank <b>${stats.qTxt.blank}</b>, invalid-format <b>${stats.qTxt.invalid}</b><br>
Note: Please verify supporting vouchers/authorisation for the above FT references.
`;
}

function fillInputterSelectors(){
  const htmlInps = uniq(state.htmlTxns.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();
  const txtInps  = uniq(state.txtTxns.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();

  const selH = document.getElementById('selHtmlInputter');
  const selT = document.getElementById('selTxtInputter');

  function fill(sel, arr){
    const cur = sel.value || "";
    sel.innerHTML = `<option value="">All</option>` + arr.map(x=>`<option value="${escapeHtml(x)}">${escapeHtml(x)}</option>`).join("");
    sel.value = arr.includes(cur) ? cur : "";
  }
  fill(selH, htmlInps);
  fill(selT, txtInps);
}

function renderAll(){
  if(!state.htmlTxns.length && !state.txtTxns.length) return;

  // Overall stats for One-page summary (NOT affected by inputter dropdowns)
  const overall = runCompare({ignoreFilters:true});
  // Filtered stats for analytics panels (affected by dropdowns)
  const filtered = runCompare({ignoreFilters:false});

  state.stats = filtered;

  // --- One-page KPIs (overall) ---
  setText("kpiResult", overall.resultBadge.text);
  setHtml("kpiStatus", `<span class="badge ${overall.resultBadge.cls}">${overall.resultBadge.cls==="ok"?"OK":"ACTION REQUIRED"}</span>`);
  setText("kpiMissingTxt", String(overall.missingTxt.length));
  setText("kpiMissingHtml", String(overall.missingHtml.length));
  setText("qHtmlBlank", overall.qHtml.blank); setText("qHtmlInvalid", overall.qHtml.invalid);
  setText("qTxtBlank", overall.qTxt.blank); setText("qTxtInvalid", overall.qTxt.invalid);

  // --- One-page Inputter summary tables (overall, fixed) ---
  setHtml("tblHtmlInputter", renderTableInputterSummary(summarizeByInputter(overall.htmlFiltered, {excludeSystem:false})));
  setHtml("tblTxtInputter", renderTableInputterSummary(summarizeByInputter(overall.txtFiltered, {excludeSystem: overall.excludeSystem})));

  // --- One-page Observation (overall, fixed) ---
  setHtml("sumObservation", buildObservation(overall));

  // --- Audit-grade KPIs (filtered) ---
  setText("exHtml", String(countExceptions(filtered.htmlFiltered)));
  setText("exTxt", String(countExceptions(filtered.txtFiltered)));
  setText("orHtml", String(countOrphans(filtered.htmlFiltered)));
  setText("orTxt", String(countOrphans(filtered.txtFiltered)));

  const leak = systemLeakReport(state.txtTxns);
  setText("sysLeakN", String(leak.count));
  setHtml("sysLeakList", leak.top.length ? leak.top.map(([u,c])=>`${escapeHtml(u)} (${c})`).join(", ") : "—");

  // --- Analytics (filtered) ---
  if(filtered.hi){
    setHtml("hiTxn", `<b>${escapeHtml(filtered.hi.ref)}</b> — ${fmt(filtered.hi.amt)} (${escapeHtml(filtered.hi.src)}; inputter: ${escapeHtml(filtered.hi.inputter||"")})`);
  }else{
    setText("hiTxn","—");
  }
  setHtml("listMissingTxt", renderMissingList(filtered.missingTxt));
  setHtml("listMissingHtml", renderMissingList(filtered.missingHtml));

  // Per inputter detailed (filtered, respects its own side filter rules)
  setHtml("tblHtmlPerInputter", renderTableInputterSummary(summarizeByInputter(filtered.htmlFiltered, {excludeSystem:false})));
  setHtml("tblTxtPerInputter", renderTableInputterSummary(summarizeByInputter(filtered.txtFiltered, {excludeSystem: filtered.excludeSystem})));

  updateTopPerUser();
  updateAdvancedChecks();
}

function renderSearch(rows){
  const head = `<thead><tr>
    <th>Src</th><th>Ref</th><th>Inputter</th><th>Debit</th><th>Credit</th><th>Time</th>
  </tr></thead>`;
  const body = rows.map(r=>`<tr>
    <td>${r.src}</td>
    <td class="rowhdr">${escapeHtml(r.ref)}</td>
    <td>${escapeHtml(r.inputter||"")}</td>
    <td>${fmt(r.debitAmt)}</td>
    <td>${fmt(r.creditAmt)}</td>
    <td>${escapeHtml(r.time||"")}</td>
  </tr>`).join("");
  return `<table>${head}<tbody>${body || `<tr><td colspan="6" class="rowhdr">—</td></tr>`}</tbody></table>`;
}

function runSearch(){
  if(!state.stats) return;
  const qI = (document.getElementById('qInputter').value||"").trim().toUpperCase();
  const qF = (document.getElementById('qFt').value||"").trim().toUpperCase();
  const qMin = num(document.getElementById('qMin').value||"0");

  const rows = [];
  function add(src, list){
    for(const t of list){
      const inp = (t.inputter||"").toUpperCase();
      const ref = (t.ref||"").toUpperCase();
      const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
      if(qI && !inp.includes(qI)) continue;
      if(qF && !ref.includes(qF)) continue;
      if(qMin && amt < qMin) continue;
      rows.push({src, ...t});
      if(rows.length>=200) return;
    }
  }
  add("HTML", state.stats.htmlFiltered);
  add("TXT", state.stats.txtFiltered);
  setHtml("tblSearch", renderSearch(rows));
}
function clearSearch(){
  document.getElementById('qInputter').value="";
  document.getElementById('qFt').value="";
  document.getElementById('qMin').value="";
  setHtml("tblSearch", "");
}

// --------------------------- Main Actions ---------------------------
function setCsvButtonsEnabled(){
  const bH = document.getElementById("dlHtmlCsv");
  const bT = document.getElementById("dlTxtCsv");
  if(bH) bH.disabled = !(state.htmlTxns && state.htmlTxns.length);
  if(bT) bT.disabled = !(state.txtTxns && state.txtTxns.length);
}

function txnsToCsv(txns){
  const header = [
    "src","ref","side","amount",
    "debitAmt","creditAmt",
    "drAcc","drTitle",
    "crAcc","crTitle",
    "inputter","authoriser",
    "time"
  ];
  const esc = (v)=>{
    const s = (v==null) ? "" : String(v);
    const out = s.replace(/"/g,'""');
    return /[",\n\r]/.test(out) ? `"${out}"` : out;
  };

  const lines = [header.join(",")];
  for(const t of (txns||[])){
    const debit = num(t.debitAmt);
    const credit = num(t.creditAmt);
    const side = (debit>0) ? "DEBIT" : ((credit>0) ? "CREDIT" : "");
    const amount = side==="CREDIT" ? credit : debit;

    lines.push([
      esc(t.src || ""),
      esc(t.ref || ""),
      esc(side),
      esc(amount ? fmt(amount) : ""),
      esc(debit ? fmt(debit) : ""),
      esc(credit ? fmt(credit) : ""),
      esc(t.drAcc || ""),
      esc(t.drTitle || ""),
      esc(t.crAcc || ""),
      esc(t.crTitle || ""),
      esc(t.inputter || ""),
      esc(t.authoriser || ""),
      esc(t.time || "")
    ].join(","));
  }
  return lines.join("\n");
}

function downloadCsv(filename, csvText){
  try{
    const blob = new Blob([csvText], {type:"text/csv;charset=utf-8"});
    // IE / old Edge fallback
    if(window.navigator && window.navigator.msSaveOrOpenBlob){
      window.navigator.msSaveOrOpenBlob(blob, filename);
      return;
    }
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.style.display = "none";
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1500);
  }catch(e){
    console.error(e);
    alert("CSV download failed. Some bank PCs block downloads from local HTML (file://). If blocked, run this page via a local server (http://localhost).");
  }
}

function downloadCurrentHtmlCsv(){
  if(!state.htmlTxns || !state.htmlTxns.length) return;
  const csv = txnsToCsv(state.htmlTxns.map(t=>({...t, src:"HTML"})));
  log("⬇️ Downloading HTML CSV…");
  downloadCsv("transfer_html.csv", csv);
}
function downloadCurrentTxtCsv(){
  if(!state.txtTxns || !state.txtTxns.length) return;
  const csv = txnsToCsv(state.txtTxns.map(t=>({...t, src:"TXT"})));
  log("⬇️ Downloading TXT CSV…");
  downloadCsv("transfer_txt.csv", csv);
}

function readFileAsText(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = ()=>resolve(String(r.result||""));
    r.onerror = ()=>reject(r.error || new Error("File read error"));
    r.readAsText(file);
  });
}

async function runAudit(){
  const btn = document.getElementById('btnRun');
  try{
    if(btn) btn.disabled = true;
    log("Loading files…");

    const fH = document.getElementById('fileHtml')?.files?.[0];
    const fT = document.getElementById('fileTxt')?.files?.[0];
    if(!fH || !fT){
      alert("Please select both HTML and TXT files.");
      return;
    }

    loadSysList();

    const [htmlText, txtText] = await Promise.all([
      readFileAsText(fH),
      readFileAsText(fT)
    ]);

    log("Parsing HTML…");
    state.htmlTxns = parseHtmlRegister(htmlText) || [];
    state.htmlTxns.forEach(t=>t.src="HTML");

    log("Parsing TXT…");
    state.txtTxns = parseTxtRegister(txtText) || [];
    state.txtTxns.forEach(t=>t.src="TXT");

    log(`HTML txns parsed: ${state.htmlTxns.length}`);
    log(`TXT txns parsed: ${state.txtTxns.length}`);

    setCsvButtonsEnabled();
    fillInputterSelectors();
    renderAll();
    log("✅ Done.");
  }catch(e){
    console.error(e);
    log("❌ Error: " + (e && e.message ? e.message : String(e)));
    alert("Error while processing. Check Debug box.");
  }finally{
    if(btn) btn.disabled = false;
  }
}

// --------------------------- Init ---------------------------
window.addEventListener('load', ()=>{
  try{ addHelpIcons(); }catch(e){}
  try{ loadSysList(); }catch(e){}

  // Wire CSV buttons once
  document.getElementById("dlHtmlCsv")?.addEventListener("click", downloadCurrentHtmlCsv);
  document.getElementById("dlTxtCsv")?.addEventListener("click", downloadCurrentTxtCsv);

  document.getElementById("topNPerUser")?.addEventListener("change", updateTopPerUser);

  document.getElementById("btnAdvRefresh")?.addEventListener("click", updateAdvancedChecks);
  document.getElementById("thrLimit")?.addEventListener("change", updateAdvancedChecks);
  document.getElementById("thrWindowPct")?.addEventListener("change", updateAdvancedChecks);

  setCsvButtonsEnabled();
});

</script>
<!-- ===================== /tools/ Footer (Optimized for Tools Pages) ===================== -->
<footer style="margin-top:16px; border-top:1px solid rgba(0,0,0,.12); padding:16px 0;">
  <div style="max-width:1100px; margin:0 auto; padding:0 12px;">

    <!-- Ads & Privacy Notice (full width) -->
    <div class="card" style="margin:0; padding:12px;"
         data-help="Ads disclosure and privacy notice for tools pages.">
      <div class="small muted"><b>Ads & Privacy Notice</b></div>
      <div class="small" style="margin-top:8px;">
        This page may display advertisements served by Google and its partners. Ads help support the maintenance of these free tools.
        Google may use cookies or similar technologies to serve and measure ads, and (where permitted) personalize ads.
      </div>
    </div>

    <!-- Quick links + Social -->
    <div class="toolsFooterRow">

      <!-- Quick Links (make it wide / flexible) -->
      <div class="card toolsFooterColWide" style="margin:0; padding:12px;"
           data-help="Essential policy and contact links for tools pages.">
        <div class="small muted"><b>Quick Links</b></div>

        <div class="small" style="margin-top:8px; line-height:1.9;">
          <a href="/privacy-policy.html" target="_blank" rel="noopener">Privacy</a> ·
          <a href="/terms.html" target="_blank" rel="noopener">Terms</a> ·
          <a href="/cookie-policy.html" target="_blank" rel="noopener">Cookies</a> ·
          <a href="/disclaimer.html" target="_blank" rel="noopener">Disclaimer</a> ·
          <a href="/contact.html" target="_blank" rel="noopener">Contact</a> ·
          <a href="/" target="_blank" rel="noopener">Home</a>
        </div>
      </div>

      <!-- Connect (narrow) -->
      <div class="card toolsFooterColNarrow" style="margin:0; padding:12px;"
           data-help="Official social profiles for Abdul Latif / ablatif.com.">
        <div class="small muted"><b>Connect</b></div>

        <div class="socialBtns">
          <a class="socialBtn" href="https://www.facebook.com/latifmirabdul/" target="_blank" rel="noopener"
             title="Facebook" aria-label="Facebook">
            <i class="fa fa-facebook"></i>
          </a>

          <a class="socialBtn" href="https://x.com/latifju" target="_blank" rel="noopener"
             title="X" aria-label="X">
            <span style="font-weight:800; font-size:16px;">X</span>
          </a>

          <a class="socialBtn" href="https://www.instagram.com/ablatifshahin/" target="_blank" rel="noopener"
             title="Instagram" aria-label="Instagram">
            <i class="fa fa-instagram"></i>
          </a>

          <a class="socialBtn" href="https://www.youtube.com/@DiptiYTV" target="_blank" rel="noopener"
             title="YouTube" aria-label="YouTube">
            <i class="fa fa-youtube-play"></i>
          </a>
        </div>

        <div class="small muted" style="margin-top:10px;">
          Email: <a href="mailto:latifshahin@gmail.com">latifshahin@gmail.com</a>
        </div>
      </div>

    </div><!-- /.toolsFooterRow -->

    <!-- Short tool disclaimer -->
    <div class="card" style="margin-top:12px; padding:12px;"
         data-help="Short disclaimer for audit tools: indicates it highlights exceptions, not proof of fraud.">
      <div class="small muted"><b>Tool Disclaimer</b></div>
      <div class="small" style="margin-top:8px;"> This note for Agrani Bank PLC officers and auditors: who are using this tool to analyze transfer registers. Please read carefully before interpreting results. This tool is designed to assist auditors in identifying potential discrepancies in transfer registers. It highlights exceptions and anomalies but does not provide conclusive evidence of fraud or error. All findings should be further investigated with supporting documentation and context. Use this tool as part of a comprehensive audit process, not as a standalone proof of wrongdoing. it is recommended to consult with audit professionals for interpretation and next steps based on the results generated by this tool. remember, the absence of discrepancies does not guarantee the absence of fraud, and the presence of discrepancies does not confirm fraud. Always consider the broader context and supporting evidence when evaluating audit findings.
      </div>
    </div>

    <!-- Copyright -->
    <div class="small muted" style="margin-top:12px; text-align:center;">
      © 2026 Abdul Latif · <a href="/blog/" target="_blank" rel="noopener">Blog</a>
    </div>

  </div><!-- /max-width wrapper -->
</footer>

<!-- ===================== /tools/ Footer End ===================== -->


</body>
</html>
