<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Professional Banking & Financial Services | Abdul Latif</title>
<meta name="description" content="Professional banking services by Abdul Latif — banking software, workflow automation, audit tools, financial research and advisory services in Bangladesh." />
<link rel="canonical" href="https://ablatif.com/services/" />
<!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-X4YNW0E3XG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-X4YNW0E3XG');
  </script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@graph": [
    {
      "@type": "Person",
      "@id": "https://ablatif.com/#person",
      "name": "Abdul Latif",
      "url": "https://ablatif.com/",
      "jobTitle": "Banking & Financial Systems Specialist",
      "sameAs": [
        "https://www.facebook.com/latifmirabdul/",
        "https://x.com/latifju",
        "https://www.youtube.com/@DiptiYTV"
      ]
    },
    {
      "@type": "Organization",
      "@id": "https://ablatif.com/#organization",
      "name": "Abdul Latif – Professional Banking Services",
      "url": "https://ablatif.com/services/",
      "founder": { "@id": "https://ablatif.com/#person" },
      "areaServed": {
        "@type": "Country",
        "name": "Bangladesh"
      }
    },
    {
      "@type": "Service",
      "name": "Professional Banking & Financial Services",
      "provider": { "@id": "https://ablatif.com/#organization" },
      "serviceType": [
        "Banking Software Development",
        "Audit & Compliance Tools",
        "Workflow Automation",
        "Financial & Economic Research",
        "Professional Advisory",
        "Requested Review & Analysis"
      ],
      "areaServed": "Bangladesh"
    }
  ]
}
</script>


<style>
:root{
  --bg:#f4f6fb;
  --card:#ffffff;
  --text:#0b1220;
  --muted:#5b6475;
  --border:#d7dbe3;
  --ok:#1b7f3b;
  --bad:#b00020;
  --warn:#b26a00;
  --blue:#1f4fd8;
}

*{box-sizing:border-box}
body{
  margin:0;
  padding:18px;
  font-family:Segoe UI, system-ui, -apple-system, Arial, Helvetica, sans-serif;
  background:var(--bg);
  color:var(--text);
}

h1{margin:0 0 12px 0; font-size:22px}
h2{margin:0 0 8px 0; font-size:16px}
h3{margin:0 0 8px 0; font-size:14px}
.small{font-size:13px}
.muted{color:var(--muted)}
.kpi{font-size:22px; font-weight:800}

.card{
  background:var(--card);
  border:1px solid rgba(0,0,0,.04);
  border-radius:14px;
  padding:14px 14px;
  margin-bottom:14px;
  box-shadow:0 4px 14px rgba(0,0,0,.08);
}

.row{display:flex; gap:12px; flex-wrap:wrap}
.col{flex:1 1 280px}
.col2{flex:1 1 520px}

.grid2{display:grid; grid-template-columns:1fr 1fr; gap:12px}
.grid3{display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px}
.grid4{display:grid; grid-template-columns:repeat(4,1fr); gap:12px}
@media (max-width: 980px){
  .grid2,.grid3,.grid4{grid-template-columns:1fr}
}

.hr{height:1px; background:var(--border); margin:12px 0}
.pill{
  display:inline-flex; align-items:center; gap:8px;
  border:1px solid var(--border);
  background:#fff;
  border-radius:999px;
  padding:8px 12px;
}

input[type="file"]{width:100%}
input[type="text"], textarea, select{
  width:100%;
  border:1px solid var(--border);
  border-radius:12px;
  padding:8px 10px;
  font-size:13px;
  background:#fff;
  color:var(--text);
}

textarea{resize:vertical}
button{
  border:1px solid var(--border);
  background:#fff;
  border-radius:12px;
  padding:9px 12px;
  cursor:pointer;
  font-weight:700;
}
button.primary{background:var(--blue); border-color:var(--blue); color:#fff}
button.ghost{background:#fff}
button:disabled{opacity:.55; cursor:not-allowed}

.badge{display:inline-block; padding:3px 9px; border-radius:999px; font-weight:800; font-size:12px; border:1px solid var(--border)}
.badge.ok{color:var(--ok); border-color:rgba(27,127,59,.35); background:rgba(27,127,59,.07)}
.badge.bad{color:var(--bad); border-color:rgba(176,0,32,.35); background:rgba(176,0,32,.07)}
.badge.warn{color:var(--warn); border-color:rgba(178,106,0,.35); background:rgba(178,106,0,.07)}

.status-matched{color:var(--ok); font-weight:900}
.status-not-matched{color:var(--bad); font-weight:900}
.delta-good{color:var(--ok); font-weight:900}
.delta-bad{color:var(--bad); font-weight:900}

table{width:100%; border-collapse:collapse; font-size:13px}
th,td{border:1px solid var(--border); padding:6px 8px; text-align:center; vertical-align:middle; color:#000}
th{background:#f1f3f6; font-weight:800}
td.rowhdr{text-align:left; font-weight:800; background:#fbfbfc}

.scroll{max-height:260px; overflow:auto; border-radius:12px; border:1px solid var(--border)}
pre{
  margin:0; padding:10px 12px;
  border-radius:12px;
  background:#0b1220;
  color:#e6edf3;
  font-size:12px;
  overflow:auto;
}

.obsWrap{border:none; border-collapse:separate; border-spacing:12px 0; margin-top:10px}
.obsWrap td{border:none; vertical-align:top; padding:0}

@page{size:A4 portrait; margin:12mm}
@media print{
  body{background:#fff}
  .no-print{display:none !important}
  .card{box-shadow:none}
  .scroll{max-height:none; overflow:visible}
  table{page-break-inside:avoid; break-inside:avoid}
  #onePage{page-break-after:always}
}

.helpIcon{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  width:18px;
  height:18px;
  margin-left:8px;
  border:1px solid var(--border);
  border-radius:50%;
  font-size:12px;
  line-height:1;
  color:var(--muted);
  cursor:help;
  user-select:none;
}
.helpIcon:hover{ border-color:var(--blue); color:var(--blue); }
</style>
</head>

<body>
<h1>Transfer Audit Tool v2.0</h1>

<div class="card no-print">
  <h2>1) Load registers</h2>
  <div class="grid3" style="margin-top:12px">
    <div class="card" style="margin:0" data-help=" Here you upload the HTML transfer register (Before COB). This is used as the baseline for totals, inputter summary and FT reference list. The tool dynamically detects the header row, so it should work even if column positions vary.">
      <div class="small muted">Before COB (HTML format transfer register)</div>
      <input type="file" id="fileHtml" accept=".html,.htm"/>
    </div>
    <div class="card" style="margin:0" data-help="Here you upload the TXT transfer register (After COB). This is used to compare with HTML (system users can be excluded, and 7-character normalization is applied).">
      <div class="small muted">After COB (TXT format transfer register)</div>
      <input type="file" id="fileTxt" accept=".txt"/>
    </div>
    <div class="card" style="margin:0" data-help="Opens the short/quick audit page (simplified workflow focusing on key risk indicators). Use it when you want a fast check, then return here for full matching and deep review.">
  <div class="row" style="display:flex; align-items:center; justify-content:space-between; gap:10px;">
    <div>
      <div class="small muted">Quick audit shortcut</div>
      <div class="small" style="margin-top:4px;">
        Open the simplified tool for a fast review of key red flags.
      </div>
    </div>

    <a href="/tools/transfer_short.html" target="_blank" rel="noopener"
       class="btn"
       style="text-decoration:none; white-space:nowrap; padding:8px 12px; border-radius:10px; border:1px solid #ccc;">
      Open quick audit →
    </a>
  </div>
</div>

  </div>

  <div class="grid3" style="margin-top:12px">
    <div class="card" style="margin:0" data-help="Counts rows where Inputter and Authoriser are different (after applying filters and 7-character normalization). Useful to spot segregation-of-duty issues.">
      <div class="small muted">Inputter ≠ Authoriser (Filtered)</div>
      <div class="small">HTML: <b id="exHtml">—</b> &nbsp; | &nbsp; TXT: <b id="exTxt">—</b></div>
    </div>
    <div class="card" style="margin:0" data-help="Counts debit or credit entries that have no matching opposite-side entry for the same reference (after filters). Helps find missing legs / incomplete postings.">
      <div class="small muted">Orphan Debit/Credit (Filtered)</div>
      <div class="small">HTML: <b id="orHtml">—</b> &nbsp; | &nbsp; TXT: <b id="orTxt">—</b></div>
    </div>
    <div class="card" style="margin:0" data-help="Lists TXT rows that still look like system-user activity even when 'Exclude system' is enabled (after normalization).">
      <div class="small muted">System leakage (TXT)</div>
      <div class="small">Detected: <b id="sysLeakN">—</b></div>
      <div class="small muted" id="sysLeakList">—</div>
    </div>
  </div>

  <div class="hr"></div>

  <div class="grid2">
    <div class="pill">
      <input type="checkbox" id="chkExcludeSystem" checked/>
      <div class="small">
        <b>Exclude system-generated inputters (TXT)</b><br/>
        <span class="muted">Applies to totals & inputter comparison</span>
      </div>
    </div>

    <div>
      <div class="small muted">System inputter list (comma-separated). Use <b>*</b> for prefix (example <code>EFTHO*</code>)</div>
      <textarea id="sysList" rows="2" placeholder="SMARTBANK, DATAUPDUS, EFTHO*, SYSTEM*, BATCH*"></textarea>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="saveSysList()">Save list</button>
        <button class="ghost" onclick="resetSysList()">Reset default</button>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid3">
    <div>
      <div class="small muted">HTML inputter filter</div>
      <select id="selHtmlInputter" onchange="renderAll()"><option value="">All</option></select>
    </div>
    <div>
      <div class="small muted">TXT inputter filter</div>
      <select id="selTxtInputter" onchange="renderAll()"><option value="">All</option></select>
    </div>
    <div style="display:flex; gap:10px; align-items:flex-end; justify-content:flex-end">
      <button class="primary" id="btnRun" onclick="runAudit()">Load & Compare</button>
      <button class="ghost" onclick="window.print()">Print / Save PDF</button>
    </div>
  </div>

  <div class="small muted" style="margin-top:10px">
    Tips: TXT inputter names can be truncated. This tool uses <b>prefix match</b> (TXT name must be a prefix of HTML name).
  </div>
</div>

<div id="onePage" class="card">
  <h2>One-page Audit Summary (Print / Save as PDF)</h2>
  <div class="grid3">
    <div class="card" style="margin:0">
      <div class="small muted">Result</div>
      <div id="kpiResult" class="kpi">—</div>
      <div id="kpiStatus" class="small muted">—</div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Missing FT (TXT → HTML)</div>
      <div id="kpiMissingTxt" class="kpi">—</div>
      <div class="small muted">and HTML → TXT: <span id="kpiMissingHtml">—</span></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">FT quality</div>
      <div class="small">
        HTML blank: <b id="qHtmlBlank">—</b>, invalid: <b id="qHtmlInvalid">—</b><br/>
        TXT blank: <b id="qTxtBlank">—</b>, invalid: <b id="qTxtInvalid">—</b>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Inputter Summary (HTML) — Count + Total Amount</div>
      <div class="scroll"><div id="tblHtmlInputter"></div></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Inputter Summary (TXT) — Count + Total Amount</div>
      <div class="scroll"><div id="tblTxtInputter"></div></div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="small muted">Observation</div>
  <div id="sumObservation" class="small">—</div>
</div>

<div class="card">
  <h2>2) Transaction & Inputter Analytics</h2>
  <div class="grid3">
    <div class="card" style="margin-top:12px" data-help="For each inputter (first 7 chars), shows the top N biggest transactions (by max(debit,credit)) from HTML and TXT after filters.">
  <div class="row" style="display:flex; align-items:center; justify-content:space-between; gap:12px;">
    <div>
      <div class="small muted">Top transactions per inputter</div>
      <div class="small">Shows biggest transactions for each inputter (detail view)</div>
    </div>

    <div class="row" style="display:flex; align-items:center; gap:8px;">
      <div class="small muted">Top N</div>
      <select id="topNPerUser" style="padding:6px 8px; border-radius:10px; border:1px solid #ccc;">
        <option value="5">5</option>
        <option value="10" selected>10</option>
        <option value="20">20</option>
      </select>
    </div>
  </div>

  <div id="topPerUserWrap" style="margin-top:10px">—</div>
</div>

    <div class="card" style="margin:0">
      <div class="small muted">Missing in HTML (TXT refs)</div>
      <div class="scroll"><div id="listMissingTxt"></div></div>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="downloadText('missing_in_html.txt', state.missingTxt.join('\n'))">Download .txt</button>
        <button class="ghost" onclick="downloadHtml('missing_in_html.html', state.missingTxt)">Download .html</button>
      </div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Missing in TXT (HTML refs)</div>
      <div class="scroll"><div id="listMissingHtml"></div></div>
      <div class="row" style="margin-top:8px">
        <button class="ghost" onclick="downloadText('missing_in_txt.txt', state.missingHtml.join('\n'))">Download .txt</button>
        <button class="ghost" onclick="downloadHtml('missing_in_txt.html', state.missingHtml)">Download .html</button>
      </div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Per inputter (Filtered, HTML)</div>
      <div class="scroll"><div id="tblHtmlPerInputter"></div></div>
    </div>
    <div class="card" style="margin:0">
      <div class="small muted">Per inputter (Filtered, TXT — system excluded option applies)</div>
      <div class="scroll"><div id="tblTxtPerInputter"></div></div>
    </div>
  </div>

  

  <div class="hr"></div>

  <div class="grid2">
    <div class="card" style="margin:0">
      <div class="small muted">Find transactions by user / FT / amount</div>
      <div class="grid3">
        <div>
          <div class="small muted">Inputter contains</div>
          <input type="text" id="qInputter" placeholder="e.g., MOAZZEM, REBEKA"/>
        </div>
        <div>
          <div class="small muted">FT reference contains</div>
          <input type="text" id="qFt" placeholder="e.g., FT26033"/>
        </div>
        <div>
          <div class="small muted">Min amount</div>
          <input type="text" id="qMin" placeholder="e.g., 5000"/>
        </div>
      </div>
      <div class="row" style="margin-top:10px">
        <button class="primary" onclick="runSearch()">Search</button>
        <button class="ghost" onclick="clearSearch()">Clear</button>
      </div>
      <div class="small muted" style="margin-top:10px">Search runs on both HTML + TXT (filtered). Shows top 200 rows.</div>
      <div class="scroll" style="margin-top:10px"><div id="tblSearch"></div></div>
    </div>

    <div class="card" style="margin:0">
      <div class="small muted">Debug / Notes</div>
      <pre id="debug">Ready.</pre>
    </div>
  </div>
</div>

<script>
// --------------------------- State ---------------------------
const state = {
  htmlTxns: [],
  txtTxns: [],
  stats: null,
  missingTxt: [],
  missingHtml: [],
  sysDefault: "SMARTBANK, DATAUPDUS, EFTHO*, SYSTEM*, BATCH*, T24, T24USER",
  sysPatterns: [],
};

// --------------------------- Utilities ---------------------------

// --------------------------- Help tooltips ---------------------------

function addHelpIcons(){
  // EASIEST FUTURE EDIT:
  // Put help text directly on a card:
  //   <div class="card" data-help="My text...">
  // That always wins.
  //
  // Optional fallback map by card title (the visible .small.muted text).
  const HELP = {
    "Inputter ≠ Authoriser (Filtered)":
      "Counts rows where Inputter and Authoriser are different (after applying filters and 7-character normalization). Useful to spot segregation-of-duty issues.",
    "Orphan Debit/Credit (Filtered)":
      "Counts debit or credit entries that have no matching opposite-side entry for the same reference (after filters). Helps find missing legs / incomplete postings.",
    "System leakage (TXT)":
      "Lists TXT rows that still look like system-user activity even when 'Exclude system' is enabled (after normalization).",

    // Upload cards (optional – only used if data-help is missing)
    "Before COB (HTML format transfer register)":
      "Upload the HTML transfer register (Before COB). Used as the baseline for totals, inputter summary and FT reference list.",
    "After COB (TXT format transfer register)":
      "Upload the TXT transfer register (After COB). Used to compare with HTML (system users can be excluded).",
    "For easy audit you can bist this link":
      "Opens the short/quick audit page in a new tab."
  };

  const normalizeTitle = (s)=> (s||"").replace(/\s+/g," ").trim();

  document.querySelectorAll(".card").forEach(card=>{
    // IMPORTANT BUGFIX:
    // Cards are nested inside other cards. If we do card.querySelector(".small.muted"),
    // the *outer* card can "see" a nested title and attach the tooltip to the wrong place,
    // causing your inner card to end up with the DEFAULT text.
    //
    // So: only pick a title element that belongs to THIS card (not a nested card).
    const candidates = card.querySelectorAll(".small.muted, h2, h3, strong");
    let titleEl = null;
    for(const el of candidates){
      const ownerCard = el.closest(".card");
      if(ownerCard === card){
        titleEl = el;
        break;
      }
    }
    if(!titleEl) return;

    // Don't add twice
    if(titleEl.querySelector(":scope > .helpIcon")) return;

    // Manual per-card help (editable in HTML): <div class="card" data-help="...">
    const manual = (card.getAttribute("data-help") || "").trim();

    // Read only the *text nodes* of the title (so previously added "?" never pollutes the title)
    const rawTitle = Array.from(titleEl.childNodes)
      .filter(n => n.nodeType === Node.TEXT_NODE)
      .map(n => n.textContent)
      .join("");

    const title = normalizeTitle(rawTitle);
    const tip =
      manual ||
      HELP[title] ||
      "Shows a summary for this card based on the current filters (HTML vs TXT).";

    const icon = document.createElement("span");
    icon.className = "helpIcon";
    icon.textContent = "?";
    icon.title = tip;

    titleEl.appendChild(icon);
  });
}

function log(msg){
  const el = document.getElementById('debug');
  el.textContent = (el.textContent + "\n" + msg).trim();
  el.scrollTop = el.scrollHeight;
}
function fmt(n){
  const x = Number(n||0);
  return new Intl.NumberFormat('en-US', {minimumFractionDigits:2, maximumFractionDigits:2}).format(x);
}
function num(s){
  if(s==null) return 0;
  const t = String(s).replace(/,/g,'').trim();
  const v = parseFloat(t);
  return isNaN(v) ? 0 : v;
}
function uniq(arr){ return Array.from(new Set(arr)); }

function norm7(s){
  const t = String(s||"").trim().toUpperCase();
  return t ? t.slice(0,7) : "(BLANK)";
}

function saveSysList(){
  const v = (document.getElementById('sysList').value || "").trim();
  localStorage.setItem('tr_audit_syslist', v || state.sysDefault);
  loadSysList();
  renderAll();
  alert("Saved ✅");
}
function resetSysList(){
  localStorage.setItem('tr_audit_syslist', state.sysDefault);
  loadSysList();
  renderAll();
}
function loadSysList(){
  const v = localStorage.getItem('tr_audit_syslist');
  const raw = (v && v.trim()) ? v : state.sysDefault;
  document.getElementById('sysList').value = raw;
  state.sysPatterns = raw.split(',').map(x=>x.trim().toUpperCase()).filter(Boolean);
}
function isSystemInputter(name){
  const n = String(name||"").trim().toUpperCase();
  if(!n) return false;
  for(const p of state.sysPatterns){
    if(!p) continue;
    if(p.endsWith('*')){
      const pref = p.slice(0,-1);
      if(n.startsWith(pref)) return true;
    }else{
      if(n===p) return true;
    }
  }
  return false;
}
function prefixMatch(txtName, htmlName){
  // Compare inputters using first 7 characters only (bank ID variations: REBEKA022 vs REBEKA0222 etc.)
  return norm7(txtName) === norm7(htmlName);
}
function downloadText(filename, content){
  const blob = new Blob([content||""], {type:"text/plain;charset=utf-8"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function downloadHtml(filename, refs){
  const rows = (refs||[]).map(r=>`<tr><td>${escapeHtml(r)}</td></tr>`).join("");
  const content = `<!doctype html><meta charset="utf-8"><title>${escapeHtml(filename)}</title>
  <style>body{font-family:Arial;padding:16px}table{border-collapse:collapse}td,th{border:1px solid #ccc;padding:6px 8px}</style>
  <h3>${escapeHtml(filename)}</h3><table><thead><tr><th>FT Reference</th></tr></thead><tbody>${rows}</tbody></table>`;
  const blob = new Blob([content], {type:"text/html;charset=utf-8"});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  URL.revokeObjectURL(a.href);
}
function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

// --------------------------- Top transactions per inputter (detail view) ---------------------------
function topTxnsPerInputterBoth(htmlFiltered, txtFiltered, perN = 10){
  const m = new Map(); // inputter7 -> array of txns

  function pushTxn(t, src){
    const inputter = ((t.inputter || "") + "").slice(0,7);
    const debit = num(t.debitAmt);
    const credit = num(t.creditAmt);
    const amt = Math.max(debit, credit);
    if(!inputter || !amt) return;

    const arr = m.get(inputter) || [];
    arr.push({
      inputter,
      amt,
      ref: t.ref || "",
      debit,
      credit,
      side: debit >= credit ? "DEBIT" : "CREDIT",
      src
    });
    m.set(inputter, arr);
  }

  htmlFiltered.forEach(t => pushTxn(t, "HTML"));
  txtFiltered.forEach(t => pushTxn(t, "TXT"));

  // sort each inputter group and keep top N
  for(const [k, arr] of m){
    arr.sort((a,b) => b.amt - a.amt);
    m.set(k, arr.slice(0, perN));
  }
  return m;
}

function renderTopPerUser(map){
  const wrap = document.getElementById("topPerUserWrap");
  if(!wrap) return;

  const inputters = Array.from(map.keys()).sort((a,b)=> a.localeCompare(b));
  if(inputters.length === 0){
    wrap.textContent = "—";
    return;
  }

  wrap.innerHTML = inputters.map(inp => {
    const rows = map.get(inp) || [];
    const totalShown = rows.reduce((s,r)=> s + (r.amt||0), 0);

    const table = `
      <table style="width:100%; border-collapse:collapse; margin-top:8px">
        <thead>
          <tr>
            <th style="text-align:left; padding:6px;">#</th>
            <th style="text-align:left; padding:6px;">Src</th>
            <th style="text-align:left; padding:6px;">Ref</th>
            <th style="text-align:left; padding:6px;">Side</th>
            <th style="text-align:right; padding:6px;">Debit</th>
            <th style="text-align:right; padding:6px;">Credit</th>
            <th style="text-align:right; padding:6px;">Max</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map((r, i) => `
            <tr>
              <td style="padding:6px;">${i+1}</td>
              <td style="padding:6px;">${escapeHtml(r.src)}</td>
              <td style="padding:6px; font-family:monospace;">${escapeHtml(r.ref)}</td>
              <td style="padding:6px;">${escapeHtml(r.side)}</td>
              <td style="padding:6px; text-align:right;">${fmt(r.debit)}</td>
              <td style="padding:6px; text-align:right;">${fmt(r.credit)}</td>
              <td style="padding:6px; text-align:right;"><b>${fmt(r.amt)}</b></td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;

    return `
      <details class="card" style="margin-top:10px; padding:10px; border:1px solid var(--border); border-radius:14px; box-shadow:none;">
        <summary style="cursor:pointer; display:flex; align-items:center; justify-content:space-between; gap:12px;">
          <span><b>${escapeHtml(inp)}</b> <span class="small muted">(top ${rows.length})</span></span>
          <span class="small muted">sum shown: <b>${fmt(totalShown)}</b></span>
        </summary>
        ${table}
      </details>
    `;
  }).join("");
}

function updateTopPerUser(){
  const perN = Number(document.getElementById("topNPerUser")?.value || 10);
  if(!state.stats){
    const wrap = document.getElementById("topPerUserWrap");
    if(wrap) wrap.textContent = "—";
    return;
  }
  const m = topTxnsPerInputterBoth(state.stats.htmlFiltered, state.stats.txtFiltered, perN);
  renderTopPerUser(m);
}

// --------------------------- Parsers ---------------------------
// HTML: detect header indices dynamically from the "Daily Transfer Register" table
function parseHtmlRegister(htmlText){
  const doc = new DOMParser().parseFromString(htmlText, "text/html");
  const trs = Array.from(doc.querySelectorAll("tr"));
  let header = null;
  let headerIdx = {};
  const norm = s => (s||"").replace(/\u00a0/g,' ').trim();

  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => norm(td.textContent));
    if(tds.length >= 15 && tds.some(x => x.toLowerCase() === "trans.rf.no")){
      header = tds;
      header.forEach((h,i)=>{ headerIdx[h.toLowerCase()] = i; });
      break;
    }
  }
  if(!header){
    log("⚠️ HTML header row not found. Using fallback scan (FT-based).");
    return parseHtmlFallback(doc);
  }

  function get(tds, key){
    const i = headerIdx[key.toLowerCase()];
    if(i==null) return "";
    return (tds[i]||"").trim();
  }

  const out = [];
  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => norm(td.textContent));
    if(tds.length !== header.length) continue;
    const trno = get(tds, "tr");
    if(!/^\d+$/.test(trno)) continue;

    const ref = get(tds, "trans.rf.no");
    if(!ref) continue;

    out.push({
      src:"HTML",
      tr: trno,
      ref: ref.trim(),
      debitAmt: num(get(tds, "debit.amt")),
      creditAmt: num(get(tds, "credit.amt")),
      inputterRaw: get(tds, "inputter"),
      authoriserRaw: get(tds, "authoriser"),
      inputter: norm7(get(tds, "inputter")),
      authoriser: norm7(get(tds, "authoriser")),
      time: get(tds, "time"),
      drAcc: get(tds, "debit.ac.no"),
      crAcc: get(tds, "credit.ac.no"),
      drTitle: get(tds, "debit.acct.title"),
      crTitle: get(tds, "credit.acct.title"),
      drCat: get(tds, "dr.category"),
      crCat: get(tds, "cr.category"),
      type: get(tds, "type"),
    });
  }
  return out;
}

function parseHtmlFallback(doc){
  // fallback: scan for FT in TDs; assume columns: ... FT ref ... inputter later
  const out = [];
  const trs = Array.from(doc.querySelectorAll("tr"));
  let idx=0;
  for(const tr of trs){
    const tds = Array.from(tr.querySelectorAll("td")).map(td => (td.textContent||"").replace(/\u00a0/g,' ').trim());
    const ft = tds.find(x => /^FT[0-9A-Z]{4,}$/i.test(x));
    if(!ft) continue;
    const inputterRaw = (tds[tds.indexOf(ft)+2]||"").trim(); // heuristic
    out.push({src:"HTML", tr:String(++idx), ref:ft, debitAmt:0, creditAmt:0, inputterRaw, authoriserRaw:"", inputter:norm7(inputterRaw), authoriser:"", time:""});
  }
  return out;
}

// TXT: parse lines that contain FT token and amount columns; pick inputter token after FT
function parseTxtRegister(txtText){
  const lines = txtText.split(/\r?\n/);
  const out = [];

  function looksUserId(x){
    return /^[A-Z0-9]+$/i.test(x||"") && /[A-Z]/i.test(x||"") && /\d/.test(x||"");
  }

  for(const line of lines){
    if(!/\bFT[0-9A-Z]{4,}\b/i.test(line)) continue;

    const parts = line.trim().split(/\s+/);
    const ftIdx = parts.findIndex(p => /^FT[0-9A-Z]{4,}$/i.test(p));
    if(ftIdx < 0) continue;

    const ref = parts[ftIdx];

    // Find a time token after FT if present (HH:MM)
    let time = "";
    let timeIdx = -1;
    for(let i=ftIdx+1; i<parts.length; i++){
      if(/^\d{2}:\d{2}$/.test(parts[i])) { timeIdx = i; time = parts[i]; break; }
    }
    const end = (timeIdx>-1) ? timeIdx : parts.length;

    // Amounts:
    // TXT register is *usually* 2-line per transaction (one debit-side line + one credit-side line),
    // each line often contains only ONE amount. If we treat that single amount as both debit+credit,
    // totals become doubled. So:
    // - if we see 2+ decimal amounts on the same line => assume it's a combined debit+credit line
    // - if we see exactly 1 amount => classify the line as debit-side or credit-side and set the other side to 0
    const decs = parts.filter(p => /^[0-9,]+\.[0-9]{2}$/.test(p));
    let debitAmt = 0, creditAmt = 0;

    if(decs.length >= 2){
      debitAmt  = num(decs[0]);
      creditAmt = num(decs[decs.length-1]);
    }else if(decs.length === 1){
      const amt = num(decs[0]);

      // Heuristic side detection:
      // debit-side lines typically have a full debit account number as token[1] (10+ digits),
      // whereas credit-side lines often start with blanks and token[1] is short (e.g., "39").
      // Decide side for single-amount TXT lines using FIXED columns (not token length).
      // In this register layout:
      // - If the LEFT account field is present (after the line serial), it is a DEBIT-side line.
      // - If the LEFT field is blank and the details start later (after the repeated mid-serial),
      //   it is a CREDIT-side line.
      const leftAcctField = line.slice(3, 28).trim(); // chars right after serial
      const isDebitSide = leftAcctField.length > 0;

      if(isDebitSide){
        debitAmt = amt;
        creditAmt = 0;
      }else{
        debitAmt = 0;
        creditAmt = amt;
      }
    }

    // USER EXTRACTION RULE (bank culture):
    // - If inputter id is 9 chars -> a SPACE exists before authoriser id (separate tokens)
    // - If inputter id is 10 chars -> it may be ATTACHED with authoriser in the same token
    // Therefore we inspect the first token after FT.
    const after = parts.slice(ftIdx+1, end).filter(Boolean);
    let inputter = "", authoriser = "";

    if(after.length){
      const t0 = after[0];
      // If attached: long token that starts with 10-char inputter
      if(t0.length > 10 && looksUserId(t0.slice(0,10))){
        inputter = t0.slice(0,10);
        authoriser = t0.slice(10);
        // If authoriser didn't come out clean (e.g., trailing junk), fallback to next token
        if(!looksUserId(authoriser) && after.length>=2 && looksUserId(after[1])){
          authoriser = after[1];
        }
      }else{
        // Separate tokens (typically 9-char inputter followed by authoriser)
        inputter = t0;
        if(after.length>=2) authoriser = after[1];
      }

      // Extra safety: if inputter token looks like garbage but second token looks like user id
      if(!looksUserId(inputter) && after.length>=2 && looksUserId(after[1])){
        inputter = after[1];
        authoriser = after.length>=3 ? after[2] : authoriser;
      }
    }

    out.push({
      src:"TXT",
      tr: parts[0] || "",
      ref,
      debitAmt,
      creditAmt,
      inputterRaw: (inputter||"").trim(),
      authoriserRaw: (authoriser||"").trim(),
      inputter: norm7(inputter),
      authoriser: norm7(authoriser),
      time: (time||"").trim(),
      raw: line
    });
  }
  return out;
}

// --------------------------- Audit Engine ---------------------------
function buildIndex(txns){
  const m = new Map();
  for(const t of txns){
    const k = (t.ref||"").trim();
    if(!k) continue;
    if(!m.has(k)) m.set(k, []);
    m.get(k).push(t);
  }
  return m;
}

function ftQuality(txns){
  const fmtOk = /^FT[0-9A-Z]{6,}$/i;
  let blank=0, invalid=0;
  const samples=[];
  for(const t of txns){
    const r = (t.ref||"").trim();
    if(!r){ blank++; continue; }
    if(!fmtOk.test(r)){
      invalid++;
      if(samples.length<5) samples.push(r);
    }
  }
  return {blank, invalid, samples};
}

function summarizeByInputter(txns, opts){
  const {excludeSystem=false} = opts||{};
  const m = new Map();
  for(const t of txns){
    const raw = (t.inputterRaw!=null ? t.inputterRaw : t.inputter) || "";
    const key = (t.inputter||"").trim() || norm7(raw);
    if(excludeSystem && isSystemInputter(raw)) continue;
    if(!m.has(key)) m.set(key, {inputter:key, tx:0, debit:0, credit:0, maxAmt:0, maxRef:""});
    const r = m.get(key);
    r.tx += 1;
    r.debit += num(t.debitAmt);
    r.credit += num(t.creditAmt);
    const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
    if(amt > r.maxAmt){
      r.maxAmt = amt;
      r.maxRef = t.ref;
    }
  }
  return Array.from(m.values()).sort((a,b)=>b.tx-a.tx);
}

function countExceptions(txns){
  // inputter != authoriser (both present, case-insensitive)
  let n=0;
  for(const t of txns){
    const i = (t.inputter||"").trim().toUpperCase();
    const a = (t.authoriser||"").trim().toUpperCase();
    if(i && a && i !== a) n++;
  }
  return n;
}
function countOrphans(txns){
  // orphan = only one side has amount (>0) and the other is 0
  let n=0;
  for(const t of txns){
    const d = num(t.debitAmt), c = num(t.creditAmt);
    if((d>0 && c===0) || (c>0 && d===0)) n++;
  }
  return n;
}
function systemLeakReport(txtAll){
  // list system inputters found in TXT with counts
  const m = new Map();
  for(const t of txtAll){
    const inp = (t.inputter||"").trim();
    if(inp && isSystemInputter(inp)){
      m.set(inp, (m.get(inp)||0)+1);
    }
  }
  const arr = Array.from(m.entries()).sort((a,b)=>b[1]-a[1]);
  return {count: arr.reduce((a,[,v])=>a+v,0), top: arr.slice(0,8)};
}

function totals(txns, opts){
  const {excludeSystem=false, filterInputter=""} = opts||{};
  let d=0,c=0, dr=0, cr=0;
  for(const t of txns){
    const inp=(t.inputter||"").trim();
    const raw=(t.inputterRaw!=null ? t.inputterRaw : inp);
    if(filterInputter && inp!==filterInputter) continue;
    if(excludeSystem && isSystemInputter(raw)) continue;
    const da=num(t.debitAmt), ca=num(t.creditAmt);
    d+=da; c+=ca;
    if(da>0) dr++;
    if(ca>0) cr++;
  }
  return {debit:d, credit:c, drCount:dr, crCount:cr};
}

function runCompare(opts){
  opts = opts || {};

  const excludeSystem = document.getElementById('chkExcludeSystem').checked;

  // filters
  const fHtml = opts.ignoreFilters ? "" : (document.getElementById('selHtmlInputter').value || "");
  const fTxt  = opts.ignoreFilters ? "" : (document.getElementById('selTxtInputter').value || "");

  const htmlFiltered = state.htmlTxns.filter(t => !fHtml || (t.inputter||"")===fHtml);
  const txtFilteredRaw = state.txtTxns.filter(t => !fTxt || (t.inputter||"")===fTxt);
  const txtFiltered = excludeSystem ? txtFilteredRaw.filter(t => !isSystemInputter(t.inputterRaw||t.inputter)) : txtFilteredRaw;

  const idxHtml = buildIndex(htmlFiltered);
  const idxTxt  = buildIndex(txtFiltered);

  const missingTxt = []; // in TXT but not in HTML
  for(const [ref] of idxTxt){
    if(!idxHtml.has(ref)) missingTxt.push(ref);
  }
  const missingHtml = []; // in HTML but not in TXT
  for(const [ref] of idxHtml){
    if(!idxTxt.has(ref)) missingHtml.push(ref);
  }

  state.missingTxt = missingTxt.sort();
  state.missingHtml = missingHtml.sort();

  // Inputter compare: after excluding system on TXT and applying filters,
  // compare sets using prefix logic
  const htmlInps = uniq(htmlFiltered.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();
  const txtInps  = uniq(txtFiltered.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();

  const onlyHtml = [];
  const onlyTxt = [];
  for(const h of htmlInps){
    const matched = txtInps.some(t => prefixMatch(t,h));
    if(!matched) onlyHtml.push(h);
  }
  for(const t of txtInps){
    const matched = htmlInps.some(h => prefixMatch(t,h));
    if(!matched) onlyTxt.push(t);
  }

  const htmlTot = totals(htmlFiltered, {excludeSystem:false});
  const txtTot  = totals(txtFiltered, {excludeSystem:false}); // already excluded
  const dDelta = htmlTot.debit - txtTot.debit;
  const cDelta = htmlTot.credit - txtTot.credit;
  const bothZero = (Math.abs(dDelta) < 0.005 && Math.abs(cDelta) < 0.005);

  const qHtml = ftQuality(htmlFiltered);
  const qTxt  = ftQuality(txtFiltered);

  const resultBadge = (missingTxt.length===0 && missingHtml.length===0 && bothZero && onlyHtml.length===0 && onlyTxt.length===0)
    ? {text:"MATCHED", cls:"ok"} : {text:"DISCREPANCY", cls:"bad"};

  // Highest transaction (filtered)
  let hi = null;
  function considerHi(list, src){
    for(const t of list){
      const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
      if(!hi || amt > hi.amt){
        hi = {amt, ref:t.ref, inputter:t.inputter, src};
      }
    }
  }
  considerHi(htmlFiltered, "HTML");
  considerHi(txtFiltered, "TXT");

  // build stats for render
  return {
    excludeSystem, fHtml, fTxt,
    htmlFiltered, txtFiltered,
    missingTxt, missingHtml,
    onlyHtml, onlyTxt,
    htmlTot, txtTot, dDelta, cDelta, bothZero,
    qHtml, qTxt,
    resultBadge,
    hi
  };
}

// --------------------------- Rendering ---------------------------
function setHtml(id, html){ const el=document.getElementById(id); if(el) el.innerHTML=html; }
function setText(id, t){ const el=document.getElementById(id); if(el) el.textContent=t; }

function renderTableInputterSummary(arr){
  const rowsArr = arr || [];
  const sumTx = rowsArr.reduce((a,r)=>a+(r.tx||0),0);
  const sumDebit = rowsArr.reduce((a,r)=>a+num(r.debit),0);
  const sumCredit = rowsArr.reduce((a,r)=>a+num(r.credit),0);

  const rows = rowsArr.map(r=>`
    <tr>
      <td class="rowhdr">${escapeHtml(r.inputter)}</td>
      <td>${r.tx}</td>
      <td>${fmt(r.debit)}</td>
      <td>${fmt(r.credit)}</td>
      <td>${fmt(r.maxAmt)}</td>
      <td class="rowhdr">${escapeHtml(r.maxRef||"")}</td>
    </tr>`).join("");

  const tfoot = `
    <tfoot>
      <tr>
        <td class="rowhdr">TOTAL</td>
        <td><b>${sumTx}</b></td>
        <td><b>${fmt(sumDebit)}</b></td>
        <td><b>${fmt(sumCredit)}</b></td>
        <td colspan="2"></td>
      </tr>
    </tfoot>`;

  return `
  <table>
    <thead><tr>
      <th>Inputter</th><th>Tx</th><th>Debit</th><th>Credit</th><th>Max Amt</th><th>Max Ref</th>
    </tr></thead>
    <tbody>${rows || `<tr><td colspan="6" class="rowhdr">—</td></tr>`}</tbody>
    ${rowsArr.length ? tfoot : ""}
  </table>`;
}


function renderMissingList(refs){
  if(!refs || !refs.length) return `<div class="small muted">—</div>`;
  const rows = refs.slice(0,500).map(r=>`<div class="small">${escapeHtml(r)}</div>`).join("");
  return rows + (refs.length>500 ? `<div class="small muted">… +${refs.length-500} more</div>` : "");
}

function buildObservation(stats){
  const inpOk = (stats.onlyHtml.length===0 && stats.onlyTxt.length===0);
  const inpStatus = inpOk ? "MATCHED" : "NOT MATCHED";
  const inpBadge = inpOk ? "status-matched" : "status-not-matched";
  const onlyHtml = stats.onlyHtml.slice(0,10).join(", ");
  const onlyTxt  = stats.onlyTxt.slice(0,10).join(", ");

  const deltaCls = stats.bothZero ? "delta-good" : "delta-bad";

  const totalsTbl = `
    <table aria-label="Totals compare">
      <thead><tr><th></th><th>Debit Total</th><th>Credit Total</th></tr></thead>
      <tbody>
        <tr><td class="rowhdr">HTML</td><td>${fmt(stats.htmlTot.debit)}</td><td>${fmt(stats.htmlTot.credit)}</td></tr>
        <tr><td class="rowhdr">TXT (system excluded)</td><td>${fmt(stats.txtTot.debit)}</td><td>${fmt(stats.txtTot.credit)}</td></tr>
        <tr>
          <td class="rowhdr">Δ Difference</td>
          <td><span class="${deltaCls}">Δ ${fmt(stats.dDelta)}</span></td>
          <td><span class="${deltaCls}">Δ ${fmt(stats.cDelta)}</span></td>
        </tr>
      </tbody>
    </table>`;

  const countTbl = `
    <table aria-label="Debit/Credit counts">
      <thead><tr><th></th><th>Debit Count</th><th>Credit Count</th></tr></thead>
      <tbody>
        <tr><td class="rowhdr">HTML</td><td>${stats.htmlTot.drCount}</td><td>${stats.htmlTot.crCount}</td></tr>
        <tr><td class="rowhdr">TXT (system excluded)</td><td>${stats.txtTot.drCount}</td><td>${stats.txtTot.crCount}</td></tr>
      </tbody>
    </table>`;

  const sysExcluded = stats.excludeSystem ? uniq(state.txtTxns.filter(t=>isSystemInputter(t.inputterRaw||t.inputter)).map(t=>t.inputter)).sort() : [];
  const sysList = sysExcluded.length ? sysExcluded.join(", ") : "—";

  return `
Result: ${stats.resultBadge.text} found between Before COB (HTML) and After COB (TXT) registers.<br>
Status: <b>${stats.resultBadge.cls==="ok" ? "CLEARED" : "ACTION REQUIRED"}</b> (Manual review & verification).<br>
TXT missing in HTML (Before COB): <b>${stats.missingTxt.length}</b>; HTML missing in TXT (After COB): <b>${stats.missingHtml.length}</b><br>
Inputter check (filtered): <span class="${inpBadge}">${inpStatus}</span>
${inpOk ? "— Inputter matched (prefix match applied for truncated TXT names)." :
  `— Only in HTML: <b>${escapeHtml(onlyHtml || "—")}</b>${stats.onlyTxt.length?`; Only in TXT: <b>${escapeHtml(onlyTxt||"—")}</b>`:""}`
}
<br>
Totals compare (TXT excludes system inputters):<br>
<table class="obsWrap" aria-label="Observation tables"><tr><td>${totalsTbl}</td><td>${countTbl}</td></tr></table>
<br>
Excluded system inputters (TXT): <b>${escapeHtml(sysList)}</b><br>
FT reference quality: HTML blank <b>${stats.qHtml.blank}</b>, invalid-format <b>${stats.qHtml.invalid}</b>; TXT blank <b>${stats.qTxt.blank}</b>, invalid-format <b>${stats.qTxt.invalid}</b><br>
Note: Please verify supporting vouchers/authorisation for the above FT references.
`;
}

function fillInputterSelectors(){
  const htmlInps = uniq(state.htmlTxns.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();
  const txtInps  = uniq(state.txtTxns.map(t=>(t.inputter||"").trim()).filter(Boolean)).sort();

  const selH = document.getElementById('selHtmlInputter');
  const selT = document.getElementById('selTxtInputter');

  function fill(sel, arr){
    const cur = sel.value || "";
    sel.innerHTML = `<option value="">All</option>` + arr.map(x=>`<option value="${escapeHtml(x)}">${escapeHtml(x)}</option>`).join("");
    sel.value = arr.includes(cur) ? cur : "";
  }
  fill(selH, htmlInps);
  fill(selT, txtInps);
}

function renderAll(){
  if(!state.htmlTxns.length && !state.txtTxns.length) return;

  // Overall stats for One-page summary (NOT affected by inputter dropdowns)
  const overall = runCompare({ignoreFilters:true});
  // Filtered stats for analytics panels (affected by dropdowns)
  const filtered = runCompare({ignoreFilters:false});

  state.stats = filtered;

  // --- One-page KPIs (overall) ---
  setText("kpiResult", overall.resultBadge.text);
  setHtml("kpiStatus", `<span class="badge ${overall.resultBadge.cls}">${overall.resultBadge.cls==="ok"?"OK":"ACTION REQUIRED"}</span>`);
  setText("kpiMissingTxt", String(overall.missingTxt.length));
  setText("kpiMissingHtml", String(overall.missingHtml.length));
  setText("qHtmlBlank", overall.qHtml.blank); setText("qHtmlInvalid", overall.qHtml.invalid);
  setText("qTxtBlank", overall.qTxt.blank); setText("qTxtInvalid", overall.qTxt.invalid);

  // --- One-page Inputter summary tables (overall, fixed) ---
  setHtml("tblHtmlInputter", renderTableInputterSummary(summarizeByInputter(overall.htmlFiltered, {excludeSystem:false})));
  setHtml("tblTxtInputter", renderTableInputterSummary(summarizeByInputter(overall.txtFiltered, {excludeSystem: overall.excludeSystem})));

  // --- One-page Observation (overall, fixed) ---
  setHtml("sumObservation", buildObservation(overall));

  // --- Audit-grade KPIs (filtered) ---
  setText("exHtml", String(countExceptions(filtered.htmlFiltered)));
  setText("exTxt", String(countExceptions(filtered.txtFiltered)));
  setText("orHtml", String(countOrphans(filtered.htmlFiltered)));
  setText("orTxt", String(countOrphans(filtered.txtFiltered)));

  const leak = systemLeakReport(state.txtTxns);
  setText("sysLeakN", String(leak.count));
  setHtml("sysLeakList", leak.top.length ? leak.top.map(([u,c])=>`${escapeHtml(u)} (${c})`).join(", ") : "—");

  // --- Analytics (filtered) ---
  if(filtered.hi){
    setHtml("hiTxn", `<b>${escapeHtml(filtered.hi.ref)}</b> — ${fmt(filtered.hi.amt)} (${escapeHtml(filtered.hi.src)}; inputter: ${escapeHtml(filtered.hi.inputter||"")})`);
  }else{
    setText("hiTxn","—");
  }
  setHtml("listMissingTxt", renderMissingList(filtered.missingTxt));
  setHtml("listMissingHtml", renderMissingList(filtered.missingHtml));

  // Per inputter detailed (filtered, respects its own side filter rules)
  setHtml("tblHtmlPerInputter", renderTableInputterSummary(summarizeByInputter(filtered.htmlFiltered, {excludeSystem:false})));
  setHtml("tblTxtPerInputter", renderTableInputterSummary(summarizeByInputter(filtered.txtFiltered, {excludeSystem: filtered.excludeSystem})));

  updateTopPerUser();
}

function renderSearch(rows){
  const head = `<thead><tr>
    <th>Src</th><th>Ref</th><th>Inputter</th><th>Debit</th><th>Credit</th><th>Time</th>
  </tr></thead>`;
  const body = rows.map(r=>`<tr>
    <td>${r.src}</td>
    <td class="rowhdr">${escapeHtml(r.ref)}</td>
    <td>${escapeHtml(r.inputter||"")}</td>
    <td>${fmt(r.debitAmt)}</td>
    <td>${fmt(r.creditAmt)}</td>
    <td>${escapeHtml(r.time||"")}</td>
  </tr>`).join("");
  return `<table>${head}<tbody>${body || `<tr><td colspan="6" class="rowhdr">—</td></tr>`}</tbody></table>`;
}

function runSearch(){
  if(!state.stats) return;
  const qI = (document.getElementById('qInputter').value||"").trim().toUpperCase();
  const qF = (document.getElementById('qFt').value||"").trim().toUpperCase();
  const qMin = num(document.getElementById('qMin').value||"0");

  const rows = [];
  function add(src, list){
    for(const t of list){
      const inp = (t.inputter||"").toUpperCase();
      const ref = (t.ref||"").toUpperCase();
      const amt = Math.max(num(t.debitAmt), num(t.creditAmt));
      if(qI && !inp.includes(qI)) continue;
      if(qF && !ref.includes(qF)) continue;
      if(qMin && amt < qMin) continue;
      rows.push({src, ...t});
      if(rows.length>=200) return;
    }
  }
  add("HTML", state.stats.htmlFiltered);
  add("TXT", state.stats.txtFiltered);
  setHtml("tblSearch", renderSearch(rows));
}
function clearSearch(){
  document.getElementById('qInputter').value="";
  document.getElementById('qFt').value="";
  document.getElementById('qMin').value="";
  setHtml("tblSearch", "");
}

// --------------------------- Main Actions ---------------------------
async function readFileAsText(file){
  return new Promise((resolve,reject)=>{
    const r = new FileReader();
    r.onload = ()=>resolve(String(r.result||""));
    r.onerror = reject;
    r.readAsText(file);
  });
}

async function runAudit(){
  try{
    document.getElementById('btnRun').disabled = true;
    log("Loading files…");

    const fH = document.getElementById('fileHtml').files[0];
    const fT = document.getElementById('fileTxt').files[0];
    if(!fH || !fT){
      alert("Please select both HTML and TXT files.");
      document.getElementById('btnRun').disabled = false;
      return;
    }

    loadSysList();

    const [htmlText, txtText] = await Promise.all([readFileAsText(fH), readFileAsText(fT)]);
    log("Parsing HTML…");
    state.htmlTxns = parseHtmlRegister(htmlText);
    log("Parsing TXT…");
    state.txtTxns = parseTxtRegister(txtText);

    log(`HTML txns parsed: ${state.htmlTxns.length}`);
    log(`TXT txns parsed: ${state.txtTxns.length}`);

    fillInputterSelectors();
    renderAll();
    log("✅ Done.");
  }catch(e){
    console.error(e);
    log("❌ Error: " + (e && e.message ? e.message : String(e)));
    alert("Error while processing. Check Debug box.");
  }finally{
    document.getElementById('btnRun').disabled = false;
  }
}

window.addEventListener('load', ()=>{
  addHelpIcons();
  loadSysList();
  setHtml("tblSearch","");
  document.getElementById("topNPerUser")?.addEventListener("change", updateTopPerUser);

});
</script>

</body>
</html>
